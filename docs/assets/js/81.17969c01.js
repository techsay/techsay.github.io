(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{390:function(n,t,s){"use strict";s.r(t);var a=s(4),e=Object(a.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("汇编语法种类如此之多，那么该如何学习，有没有学习的必要呢？")]),n._v(" "),t("p",[n._v("为什么会有这么多种类呢？ 我门学习C语言也都是通用的啊。")]),n._v(" "),t("p",[n._v("要明白这些，语言发展历史有必要先了解一下：")]),n._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[n._v("编程语言发展（chatGPT）")]),n._v(" "),t("p",[n._v("编程语言是计算机科学中的重要组成部分，随着计算机科技的不断发展，编程语言也在不断地发展和演进。以下是编程语言发展的总结：")]),n._v(" "),t("ol",[t("li",[n._v("机器语言和汇编语言：在计算机发明之初，程序员需要使用机器语言和汇编语言来编写程序，这些语言的基础是二进制代码，非常难以编写和维护。")]),n._v(" "),t("li",[n._v("高级语言的出现：1950年代和1960年代，高级语言开始出现，例如Fortran、COBOL和LISP等，这些语言使得程序员能够更加方便地编写代码，同时也能够提高代码的可读性和维护性。")]),n._v(" "),t("li",[n._v("C语言的兴起：1970年代，C语言的出现引起了一场编程语言的革命，C语言不仅在性能方面比高级语言更强，而且也具有更好的可读性和可维护性。")]),n._v(" "),t("li",[n._v("面向对象编程的兴起：在1980年代，面向对象编程（OOP）开始流行起来，这种编程方式更加注重代码的组织和封装，使得程序员能够更加方便地编写和维护大型软件系统。")]),n._v(" "),t("li",[n._v("脚本语言的出现：1990年代，脚本语言开始出现，例如Perl、Python和Ruby等，这些语言通常使用解释器而不是编译器来运行，使得程序员能够更加方便地编写和运行脚本程序。")]),n._v(" "),t("li",[n._v("Web编程的兴起：20世纪90年代末和21世纪初，Web编程开始流行起来，JavaScript、PHP和ASP等语言成为Web编程的主流语言，这些语言使得程序员能够更加方便地开发Web应用程序。")]),n._v(" "),t("li",[n._v("并行编程和函数式编程的兴起：近年来，并行编程和函数式编程成为编程语言发展的热点，例如Go和Scala等语言支持并行编程，而Haskell和Clojure等语言则支持函数式编程，这些语言的出现使得程序员能够更加高效地编写并发和高性能的程序。")])]),n._v(" "),t("p",[n._v("总的来说，编程语言的发展经历了从低级语言到高级语言、从过程式编程到面向对象编程、从编译型语言到解释型语言、从单线程到并行编程、从命令式编程到函数式编程等多个阶段。未来，随着计算机科技的不断发展，编程语言也会继续演变和创新，为程序员提供更加高效、可靠和易用的工具。")])]),n._v(" "),t("div",{staticClass:"custom-block danger"},[t("p",{staticClass:"custom-block-title"},[n._v("语言发展白话文")]),n._v(" "),t("div",{staticClass:"language-scss extra-class"},[t("pre",{pre:!0,attrs:{class:"language-scss"}},[t("code",[n._v("\n机器语言 ----\x3e 汇编语言  ----\x3e  面向过程语言（比如C）  ----\x3e  面向对象（比如C++） ---\x3e 。。。\n\n一、机器语言\n\n设备硬件（电脑，手机等）先要有电，电流驱动设备转换和读取 01010这样的信号，\n这样由 0和1 组成的代码叫【机器码】，也是就是硬件设备能看懂的语言。\n\n早期程序员就是一个一个手动敲打这些 0，1 组成的机器代码，然后输入设备运行的，\n随着功能愈发复杂，程序员已经无法更好写代码了\n\n比如，你能找到下面两段代码的区别吗？\n\n正确”Hello"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" world!“二进制"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(":")]),n._v("\n01001000 01100101 01101100 01101100 01101111 00101100 00100000 01110111 01101111 01110010 01101100 01100100 00100001\n\n错误”Hello"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" world!“二进制"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(":")]),n._v("\n01001000 01100101 01101100 01101100 01101111 00101000 00100000 01110111 01101111 01110010 01101100 01100100 00100001\n\n二、汇编语言\n\n1、汇编语言来源：\n为解决这些物理设备之间通信难的问题，开发出来一套人类能直接理解的【命令语】，\n然后再开发一套中间设备来【翻译】成机器码，这样，我们人类就不用直接写0和1的机器码了，直接写一些命令就行，\n比如，移动数据动作使用mov（move简写）表示，返回ret （return 的简写）表示这样就很好理解了。\n\n那么汇编语言就产生了：\n汇编语言由一套指令集合组成，通过对应的【编译器】将指令翻译成 0和1组成的机器码，然后机器就可以运行了。\n\n2、汇编语言分类：\n因为设备及芯片不同厂家是不一样的，自然通信命令也就不一样了，\n而汇编是这些机器码的命令集合，自然也就多种多样了\n另外，设备一旦购买，新设备的新指令肯定是不能支持在旧设备上运行的，\n好比幼儿园的学生看不懂小学的课程，小学生看不懂初中课程一样。\n\n目前主要的CPU架构有x86架构和ARM架构，因此常见的汇编语言分为两大类：X86汇编语言、ARM汇编语言。\n\n比如英特尔intel芯片的cpu架构是X86的，Windows设备等等\n苹果芯片早期都是intel芯片，现在使用的M1，M2等使用ARM芯片集成的\n我国的龙芯使用的是MIPS架构\n还有PowerPC架构等等\n\nX86：\nX86汇编语言，根据处理器型号可以分为很多类，\n比如\n8086汇编（16位）、\n80X88汇编（也叫IBM PC汇编，16位）、\n80X86汇编（X大于3则指32位汇编）。\n\nX86汇编语言有两种语法风格，\n即Intel汇编和AT&T汇编。\n还有X86_64位等等，\n\n简单理解都是向下兼容基于早期86命名发展起来，有8位，16位，32位，64位处理器。指令集自然存在区别。\n\nARM：\nARM汇编语言也有两种语法风格，即ARM官方汇编和ARM GNU汇编。\n前者使用ARM官方提供的汇编器ARM ASM，适合在windows中使用，一般用大写字母编写代码。\n后者使用GNU提供的汇编器"),t("span",{pre:!0,attrs:{class:"token module-modifier keyword"}},[n._v("as")]),n._v("，适合在linux中使用，一般用小写字母编写代码。\n两者主要的区别在于伪操作不同，其他相关的指令基本上是一致的。\n\n\n3、汇编器的种类\n汇编器的作用，是把汇编语言转换成机器码。\n\n常见的汇编器包括ARM ASM、MASM、TASM、GAS等。\n高级的汇编器如MASM、TASM等，提供了很多类似于高级语言的特征，比如结构化、抽象等，\n在这些环境中编写的汇编程序，有很大的一部分是面向汇编器的伪指令。\n\n（1）MASM。MASM是Microsoft Macro Assembler 的缩写，\n是微软公司为x86 微处理器家族开发的汇编开发环境，拥有可视化的开发界面，\n使开发人员不必再使用DOS环境进行汇编的开发，编译速度快，支持80x86汇编以及Win32汇编，\n是Windows下开发汇编的利器。不过微软现在不再发行MASM，此功能已经集成在visual studio 中。\n\n（2）TASM。Borland公司开发的汇编器，被广泛用于Turbo C，Quick Basic等编译器，\n用作中间过渡编译。它也能独立的编译纯汇编或是Win32Asm的代码。\n具有编译快速，高效的特点，至今依然是汇编开发的首选利器。\n\n（3）GAS。GAS是GNU Assembler的缩写。它是自由软件基金会的产品，可以支持不同的处理器，\n能够自动探测出实际的处理器架构，以生成相应的代码。\n另外也支持在某处理器平台上产生另一处理器平台的代码。\n\n\n三、C语言\n前面介绍到，汇编指令因芯片多样而各不完全相同，随着发展，程序员也不可能了解全部的汇编指令，\n同时随着软件系统复杂度上升，汇编的学习成本加大，可维护性降低，\n这些都是不能容忍的，那么高级语言的发展成为必然。\n\nc语言作为汇编更上一层的语言由此而诞生，它通俗易懂（相对于汇编）使得发展迅速\n回过头来，我门在上篇前言中介绍到，汇编语言打印 “Hello"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" world!” 是有多么的复杂难懂，\n但是在c语言中打印只需要一行代码：\n"),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("printf")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"Hello, world!"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n\nc语言可以很方便表示功能流程，更好的组织了汇编指令能力，\n开发者只需要将这些功能逻辑按照业务需求进行串联组织起来就行，\n然后由 c语言编译器 来将 代码翻译成不同系统能够识别的低级语言汇编指令，\n最终由汇编器翻译成机器语言，然后才能运行。\n\n四、C++ 语言\n有了c语言其实大部分开发场景都应该满足了，完成从始至终完成程序的整个过程。\n那么c++语言发展原因是什么呢，是一种程序设计思想，将特定思维融入到程序语言中，\n让语言更人性化，而c++就是融入面向对象的思想。\n\n面向对象\n将人、动物、事件、其他物体等等都当成一个个不同的对象来来描述，\n这样代码具有了更好一点的可维护性，不用仔细阅读代码逻辑，\n光从对象命名和分类就能猜到这段程序可能会讲什么，干什么。\n这样的代码就更具有可阅读性，可维护性（同样因为复杂性，其编译速度通常比c语言慢，\n因为大量类对象的创建本身就是对性能的一种消耗）\n\n四、编程思想\n语言有很多种，有汇编了，c语言，c++，c#，VB，VC，OC，Swift，Java，Python，等等\n作为开发者，不能只学习语言，还要学习编程思想，语言的设计，架构设计 等等\n\n有面向过程，有面向对象，有面向切面，有面向协议 等等，\n只要你的设计在不同领域带来便利就是一种好的设计\n而学习的过程中思维的升级是很重要的\n")])])])]),n._v(" "),t("p",[n._v("回到最初的问题：汇编怎么学？")]),n._v(" "),t("p",[n._v("一个小小建议：")]),n._v(" "),t("p",[n._v("x86系列是一个不错选择，当然ARM也行")]),n._v(" "),t("p",[n._v("然后就是建议16位开始学，32位和64位在16位基础上贯通即可。")]),n._v(" "),t("p",[n._v("这让我想起来大学汇编课本：《汇编语言(第x版)王爽》")]),n._v(" "),t("p",[n._v("还有大学跑马灯： 8086单片机")])])}),[],!1,null,null,null);t.default=e.exports}}]);