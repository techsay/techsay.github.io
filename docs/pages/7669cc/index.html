<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++高级教程(下) | 知识导图</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/images/hlogo.png">
    <meta name="description" content="复杂的知识体系需要一套精简的知识导图作参考和索引">
    
    <link rel="preload" href="/assets/css/0.styles.3623805a.css" as="style"><link rel="preload" href="/assets/js/app.882bfa45.js" as="script"><link rel="preload" href="/assets/js/2.d54d51d6.js" as="script"><link rel="preload" href="/assets/js/83.a593fa84.js" as="script"><link rel="prefetch" href="/assets/js/10.3bf11b9c.js"><link rel="prefetch" href="/assets/js/11.94dc8a54.js"><link rel="prefetch" href="/assets/js/12.a0bc8024.js"><link rel="prefetch" href="/assets/js/13.3cc026cd.js"><link rel="prefetch" href="/assets/js/14.ae1ec3d4.js"><link rel="prefetch" href="/assets/js/15.071d70d6.js"><link rel="prefetch" href="/assets/js/16.6b97ecae.js"><link rel="prefetch" href="/assets/js/17.7e4b9bb4.js"><link rel="prefetch" href="/assets/js/18.b06630b1.js"><link rel="prefetch" href="/assets/js/19.5dbdd31b.js"><link rel="prefetch" href="/assets/js/20.b7a450f2.js"><link rel="prefetch" href="/assets/js/21.436ee866.js"><link rel="prefetch" href="/assets/js/22.2307a6d3.js"><link rel="prefetch" href="/assets/js/23.d2423b66.js"><link rel="prefetch" href="/assets/js/24.02871e36.js"><link rel="prefetch" href="/assets/js/25.632d40b8.js"><link rel="prefetch" href="/assets/js/26.217136bb.js"><link rel="prefetch" href="/assets/js/27.9e96b1de.js"><link rel="prefetch" href="/assets/js/28.f9656d94.js"><link rel="prefetch" href="/assets/js/29.8d985ecc.js"><link rel="prefetch" href="/assets/js/3.ace22eb5.js"><link rel="prefetch" href="/assets/js/30.0b558aad.js"><link rel="prefetch" href="/assets/js/31.67451f2e.js"><link rel="prefetch" href="/assets/js/32.71191188.js"><link rel="prefetch" href="/assets/js/33.f95e4095.js"><link rel="prefetch" href="/assets/js/34.69012502.js"><link rel="prefetch" href="/assets/js/35.7ccb1f3f.js"><link rel="prefetch" href="/assets/js/36.37443201.js"><link rel="prefetch" href="/assets/js/37.5e6a6705.js"><link rel="prefetch" href="/assets/js/38.b3ebdece.js"><link rel="prefetch" href="/assets/js/39.16d4b982.js"><link rel="prefetch" href="/assets/js/4.dd3209f8.js"><link rel="prefetch" href="/assets/js/40.5b908946.js"><link rel="prefetch" href="/assets/js/41.0cd797ec.js"><link rel="prefetch" href="/assets/js/42.d7c68f84.js"><link rel="prefetch" href="/assets/js/43.30bd613b.js"><link rel="prefetch" href="/assets/js/44.e545f3d6.js"><link rel="prefetch" href="/assets/js/45.05760661.js"><link rel="prefetch" href="/assets/js/46.7cad12b0.js"><link rel="prefetch" href="/assets/js/47.ec760191.js"><link rel="prefetch" href="/assets/js/48.5060e89a.js"><link rel="prefetch" href="/assets/js/49.119d74eb.js"><link rel="prefetch" href="/assets/js/5.89429c73.js"><link rel="prefetch" href="/assets/js/50.958bd1de.js"><link rel="prefetch" href="/assets/js/51.1a0b8dd1.js"><link rel="prefetch" href="/assets/js/52.79b05b5b.js"><link rel="prefetch" href="/assets/js/53.b8ae6521.js"><link rel="prefetch" href="/assets/js/54.2cbbc869.js"><link rel="prefetch" href="/assets/js/55.b9ac328b.js"><link rel="prefetch" href="/assets/js/56.6fea09d7.js"><link rel="prefetch" href="/assets/js/57.5be1fcc8.js"><link rel="prefetch" href="/assets/js/58.9d1a1894.js"><link rel="prefetch" href="/assets/js/59.e6ebf038.js"><link rel="prefetch" href="/assets/js/6.450221bf.js"><link rel="prefetch" href="/assets/js/60.83efada3.js"><link rel="prefetch" href="/assets/js/61.ec590b42.js"><link rel="prefetch" href="/assets/js/62.740480ed.js"><link rel="prefetch" href="/assets/js/63.2533f75a.js"><link rel="prefetch" href="/assets/js/64.4996a4d2.js"><link rel="prefetch" href="/assets/js/65.90fd057c.js"><link rel="prefetch" href="/assets/js/66.2bb6b674.js"><link rel="prefetch" href="/assets/js/67.2de3fb90.js"><link rel="prefetch" href="/assets/js/68.1546e1c3.js"><link rel="prefetch" href="/assets/js/69.2aeea7f2.js"><link rel="prefetch" href="/assets/js/7.4e8d00cb.js"><link rel="prefetch" href="/assets/js/70.47d220f8.js"><link rel="prefetch" href="/assets/js/71.49ed959a.js"><link rel="prefetch" href="/assets/js/72.cd551889.js"><link rel="prefetch" href="/assets/js/73.b58484e7.js"><link rel="prefetch" href="/assets/js/74.55fe5271.js"><link rel="prefetch" href="/assets/js/75.a928c162.js"><link rel="prefetch" href="/assets/js/76.85b84080.js"><link rel="prefetch" href="/assets/js/77.656f7628.js"><link rel="prefetch" href="/assets/js/78.0703d019.js"><link rel="prefetch" href="/assets/js/79.9388afe6.js"><link rel="prefetch" href="/assets/js/8.614086e6.js"><link rel="prefetch" href="/assets/js/80.b2495b04.js"><link rel="prefetch" href="/assets/js/81.7a038ec2.js"><link rel="prefetch" href="/assets/js/82.fdf5605b.js"><link rel="prefetch" href="/assets/js/84.6b378c83.js"><link rel="prefetch" href="/assets/js/85.df87807e.js"><link rel="prefetch" href="/assets/js/86.79512f2e.js"><link rel="prefetch" href="/assets/js/87.7195fa0a.js"><link rel="prefetch" href="/assets/js/88.30e8ad1b.js"><link rel="prefetch" href="/assets/js/89.ca16ee3b.js"><link rel="prefetch" href="/assets/js/9.6285861c.js"><link rel="prefetch" href="/assets/js/90.9231fc45.js"><link rel="prefetch" href="/assets/js/91.5adca1fa.js"><link rel="prefetch" href="/assets/js/92.9ea8bc5c.js"><link rel="prefetch" href="/assets/js/93.063dcdce.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3623805a.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/logo2.png" alt="知识导图" class="logo"> <span class="site-name can-hide">知识导图</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/3468b2/" class="nav-link">iOS知识</a></div><div class="nav-item"><a href="/pages/603316/" class="nav-link">计算机软件</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="友情链接" class="dropdown-title"><!----> <span class="title" style="display:;">友情链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="http://www.52im.net/index.php" target="_blank" rel="noopener noreferrer" class="nav-link external">
  即时通讯网
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://zhuanlan.zhihu.com/p/409277420" target="_blank" rel="noopener noreferrer" class="nav-link external">
  开发常用网站
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/3468b2/" class="nav-link">iOS知识</a></div><div class="nav-item"><a href="/pages/603316/" class="nav-link">计算机软件</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="友情链接" class="dropdown-title"><!----> <span class="title" style="display:;">友情链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="http://www.52im.net/index.php" target="_blank" rel="noopener noreferrer" class="nav-link external">
  即时通讯网
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://zhuanlan.zhihu.com/p/409277420" target="_blank" rel="noopener noreferrer" class="nav-link external">
  开发常用网站
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MD</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>C语法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>C++语法</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/26aff5/" class="sidebar-link">C++基础概念(上)</a></li><li><a href="/pages/97e4a9/" class="sidebar-link">C++基础概念(下)</a></li><li><a href="/pages/c3e7e9/" class="sidebar-link">C++语法速查</a></li><li><a href="/pages/40e961/" class="sidebar-link">C++面向对象(上)</a></li><li><a href="/pages/d37cff/" class="sidebar-link">C++面向对象(下)</a></li><li><a href="/pages/00d66a/" class="sidebar-link">C++高级教程(上)</a></li><li><a href="/pages/0b5e9c/" class="sidebar-link">C++高级教程(中)</a></li><li><a href="/pages/7669cc/" aria-current="page" class="active sidebar-link">C++高级教程(下)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/7669cc/#信号处理" class="sidebar-link">信号处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#常见异常信号" class="sidebar-link">常见异常信号</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#捕获异常信号" class="sidebar-link">捕获异常信号</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#抛出异常信号" class="sidebar-link">抛出异常信号</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/7669cc/#多线程" class="sidebar-link">多线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#一些概念" class="sidebar-link">一些概念</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#创建线程" class="sidebar-link">创建线程</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#编译命令" class="sidebar-link">编译命令</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#join与detach" class="sidebar-link">join与detach</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#this-thread" class="sidebar-link">this_thread</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/7669cc/#锁-多线程" class="sidebar-link">锁（多线程）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#互斥锁mutex" class="sidebar-link">互斥锁mutex</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#_1、lock与unlock" class="sidebar-link">1、lock与unlock</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#_2、lock-guard" class="sidebar-link">2、lock_guard</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#_3、unique-lock" class="sidebar-link">3、unique_lock</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#死锁" class="sidebar-link">死锁</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/7669cc/#条件变量-线程" class="sidebar-link">条件变量（线程）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#_1、wait" class="sidebar-link">1、wait</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#_2、wait-for" class="sidebar-link">2、wait_for</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/7669cc/#线程池" class="sidebar-link">线程池</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#概念" class="sidebar-link">概念</a></li><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#线程池的实现" class="sidebar-link">线程池的实现</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/7669cc/#cgi" class="sidebar-link">CGI</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/7669cc/#什么是cgi" class="sidebar-link">什么是CGI</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>软件编程及算法</span></li><li data-v-06225672><span data-v-06225672>C++语法</span></li></ul> <div class="info" data-v-06225672><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-07-05</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">C++高级教程(下)<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="信号处理"><a href="#信号处理" class="header-anchor">#</a> 信号处理</h2> <p>信号通常由操作系统的内核在发生检查到异常的时候发出的信号</p> <p>有些信号可能会直接终中断当前的程序进程，开发人员可以在适当的时机处理对应异常情况</p> <p>在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断</p> <p>在移动端通常需要开发人员提前处理，否则可能导致程序的直接奔溃</p> <h3 id="常见异常信号"><a href="#常见异常信号" class="header-anchor">#</a> 常见异常信号</h3> <p>头文件 csignal 中下表所列信号可以在程序中捕获</p> <table><thead><tr><th style="text-align:left;">信号</th> <th style="text-align:left;">描述</th></tr></thead> <tbody><tr><td style="text-align:left;">SIGABRT</td> <td style="text-align:left;">程序的异常终止，如调用 <strong>abort</strong>。</td></tr> <tr><td style="text-align:left;">SIGFPE</td> <td style="text-align:left;">错误的算术运算，比如除以零或导致溢出的操作。</td></tr> <tr><td style="text-align:left;">SIGILL</td> <td style="text-align:left;">检测非法指令。</td></tr> <tr><td style="text-align:left;">SIGINT</td> <td style="text-align:left;">接收到交互注意信号。</td></tr> <tr><td style="text-align:left;">SIGSEGV</td> <td style="text-align:left;">非法访问内存。</td></tr> <tr><td style="text-align:left;">SIGTERM</td> <td style="text-align:left;">发送到程序的终止请求。</td></tr></tbody></table> <h3 id="捕获异常信号"><a href="#捕获异常信号" class="header-anchor">#</a> 捕获异常信号</h3> <p><strong>signal() 函数</strong></p> <p>C++ 信号处理库提供了 <strong>signal</strong> 函数，用来捕获突发事件：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/// 第一个参数:是一个整数，代表了信号的编号</span>
<span class="token comment">/// 第二个参数:是一个指向信号处理函数的指针</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">signal</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>模拟捕获异常信息示例：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;csignal&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">signalHandler</span><span class="token punctuation">(</span> <span class="token keyword">int</span> signum <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;捕获到异常信息类型值： (&quot;</span> <span class="token operator">&lt;&lt;</span> signum <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;) .\n&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// 终止程序  </span>
    <span class="token function">exit</span><span class="token punctuation">(</span>signum<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 注册信号处理程序</span>
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGABRT<span class="token punctuation">,</span> signalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGFPE<span class="token punctuation">,</span> signalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGILL<span class="token punctuation">,</span> signalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> signalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGSEGV<span class="token punctuation">,</span> signalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> signalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>  

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;计算 5/0 = &quot;</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">0</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的代码分母=0时计算异常结果：</p> <div class="language-scss extra-class"><pre class="language-scss"><code>计算 5/0 = 
捕获到异常信息 <span class="token punctuation">(</span>8<span class="token punctuation">)</span> .
main.<span class="token property">cpp</span><span class="token punctuation">:</span> In function ‘int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>’<span class="token punctuation">:</span>
main.<span class="token property">cpp</span><span class="token punctuation">:</span><span class="token property">26</span><span class="token punctuation">:</span><span class="token property">14</span><span class="token punctuation">:</span> <span class="token property">warning</span><span class="token punctuation">:</span> division by zero [-Wdiv-by-zero]
   26 |     cout &lt;&lt; 5/0 &lt;&lt; endl<span class="token punctuation">;</span>
      |             ~^~


Exited <span class="token module-modifier keyword">with</span> error status 8
</code></pre></div><p>信号SIGFPE：</p> <div class="language-scss extra-class"><pre class="language-scss"><code>FPE是floating-point exception（浮点异常）的首字母缩略字。在发生致命的算术运算错误时发出. 不仅包括浮点运算错误<span class="token punctuation">,</span> 还包括溢出及除数为0等其它所有的算术的错误。SIGFPE的符号常量在头文件signal.h中定义。

错误的算术操作 SA SIGINFO宏：

FPE INTDIV 整数除以零
FPE INTOVF 整数上溢
FPE FLTDIV 浮点除以零
FPE FLTOVF 浮点上溢
FPE FLTUND 浮点下溢
FPE FLTRES 浮点结果不准
FPE FLTINV 无效浮点操作
FPE FLTSUB 浮点下标越界
</code></pre></div><h3 id="抛出异常信号"><a href="#抛出异常信号" class="header-anchor">#</a> 抛出异常信号</h3> <p><strong>raise() 函数</strong>抛出异常信号如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">raise</span> <span class="token punctuation">(</span>signal sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>示例：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;csignal&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">signalHandler</span><span class="token punctuation">(</span> <span class="token keyword">int</span> signum <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;捕获到异常信息类型值： (&quot;</span> <span class="token operator">&lt;&lt;</span> signum <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;) .\n&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// 终止程序  </span>
    <span class="token function">exit</span><span class="token punctuation">(</span>signum<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 注册算术运算错误 SIGFPE 信号处理程序</span>
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGFPE<span class="token punctuation">,</span> signalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
  	<span class="token comment">// 手动抛出算术运算错误异常</span>
    <span class="token function">raise</span><span class="token punctuation">(</span>SIGFPE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果：</p> <div class="language-scss extra-class"><pre class="language-scss"><code>捕获到异常信息类型值： <span class="token punctuation">(</span>8<span class="token punctuation">)</span> .


Exited <span class="token module-modifier keyword">with</span> error status 8
</code></pre></div><p>更多异常参考signal 文件。</p> <hr> <p>下面 linux—signal信号：</p> <table><thead><tr><th>linux_signal信号</th> <th></th> <th></th></tr></thead> <tbody><tr><td>SIGHUP</td> <td>SIGHUP，hong up ，挂断。本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。  登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和 后台进程组，一般都属于这个 Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进 程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也 能继续下载。 此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</td> <td></td></tr> <tr><td>SIGINT</td> <td>程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl+C)时发出，用于通知前台进程组终止进程。</td> <td></td></tr> <tr><td>SIGQUIT</td> <td>和SIGINT类似, 但由QUIT字符(通常是Ctrl+)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号</td> <td></td></tr> <tr><td>SIGILL</td> <td>SIGILL，illeage，非法的。执行了非法指令， 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出也有可能产生这个信号。</td> <td></td></tr> <tr><td>SIGTRAP</td> <td>由断点指令或其它陷阱（trap）指令产生. 由debugger使用</td> <td></td></tr> <tr><td>SIGABRT</td> <td>调用abort函数生成的信号。</td> <td></td></tr> <tr><td>SIGBUS</td> <td>非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)</td> <td></td></tr> <tr><td>SIGFPE</td> <td>FPE是floating-point exception（浮点异常）的首字母缩略字。在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。SIGFPE的符号常量在头文件signal.h中定义。<br>    在这里插入图片描述</td> <td></td></tr> <tr><td>SIGKILL</td> <td>用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号，终极大招。</td> <td></td></tr> <tr><td>SIGUSR1</td> <td>留给用户使用</td> <td></td></tr> <tr><td>SIGSEGV</td> <td>试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据</td> <td></td></tr> <tr><td>SIGUSR2</td> <td>留给用户使用</td> <td></td></tr> <tr><td>SIGPIPE</td> <td>管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止</td> <td></td></tr> <tr><td>SIGALRM</td> <td>时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号</td> <td></td></tr> <tr><td>SIGTERM</td> <td>程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。</td> <td></td></tr> <tr><td>SIGCHLD</td> <td>子进程（child）结束时, 父进程会收到这个信号。如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这 时的子进程称为僵尸进程。这种情 况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程 来接管)。</td> <td></td></tr> <tr><td>SIGCONT</td> <td>让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符</td> <td></td></tr> <tr><td>SIGSTOP</td> <td>暂停(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略</td> <td></td></tr> <tr><td>SIGTSTP</td> <td>停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl+Z)发出这个信号</td> <td></td></tr> <tr><td>SIGTTIN</td> <td>当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.<br>           Unix环境下，当一个进程以后台形式启动，但尝试去读写控制台终端时，将会触发SIGTTIN（读）和SIGTTOU（写）信号量，接着，进程将会暂停（linux默认情况下），read/write将会返回错误。这个时候，shell将会发送通知给用户，提醒用户切换此进程为前台进程，以便继续执行。由后台切换至前台的方式是fg命令，前台转为后台则为CTRL+Z快捷键。<br>    那么问题来了，如何才能在不把进程切换至前台的情况下，读写控制器不会被暂停？答案：只要忽略SIGTTIN和SIGTTOU信号量即可：signal(SIGTTOU, SIG_IGN)。<br>    stty stop/-stop命令是用于设置收到SIGTTOU信号量后是否执行暂停，因为有些系统的默认行为不一致，比如mac是默认忽略，而linux是默认启用。stty -a可以查看当前tty的配置参数。<br>    在这里插入图片描述</td> <td></td></tr> <tr><td>SIGTTOU</td> <td>类似于SIGTTIN, 但在写终端(或修改终端模式)时收到。具体见上面SIGTTIN</td> <td></td></tr> <tr><td>SIGURG</td> <td>SIGURG, urgent, 紧急的。有”紧急”数据或out-of-band数据到达socket时产生</td> <td></td></tr> <tr><td>SIGXCPU</td> <td>超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。</td> <td></td></tr> <tr><td>SIGXFSZ</td> <td>当进程企图扩大文件以至于超过文件大小资源限制</td> <td></td></tr> <tr><td>SIGVTALRM</td> <td>虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.</td> <td></td></tr> <tr><td>SIGPROF</td> <td>类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间</td> <td></td></tr> <tr><td>SIGWINCH</td> <td>Windows Change, 窗口大小改变时发出.</td> <td></td></tr> <tr><td>SIGIO</td> <td>文件描述符准备就绪, 可以开始进行输入/输出操作.</td> <td></td></tr> <tr><td>SIGPWR</td> <td>Power failure</td> <td></td></tr> <tr><td>SIGSYS</td> <td>非法的系统调用。</td> <td></td></tr></tbody></table> <div class="language-scss extra-class"><pre class="language-scss"><code>1、程序不可捕获、阻塞或忽略的信号有：SIGKILL<span class="token punctuation">,</span>SIGSTOP
    
2、不能恢复至默认动作的信号有：SIGILL<span class="token punctuation">,</span>SIGTRAP
    
3、默认会导致进程流产的信号有：SIGABRT<span class="token punctuation">,</span>SIGBUS<span class="token punctuation">,</span>SIGFPE<span class="token punctuation">,</span>SIGILL<span class="token punctuation">,</span>SIGIOT<span class="token punctuation">,</span>SIGQUIT<span class="token punctuation">,</span>SIGSEGV<span class="token punctuation">,</span>SIGTRAP<span class="token punctuation">,</span>SIGXCPU<span class="token punctuation">,</span>SIGXFSZ
    
4、默认会导致进程退出的信号有：SIGALRM<span class="token punctuation">,</span>SIGHUP<span class="token punctuation">,</span>SIGINT<span class="token punctuation">,</span>SIGKILL<span class="token punctuation">,</span>SIGPIPE<span class="token punctuation">,</span>SIGPOLL<span class="token punctuation">,</span>SIGPROF<span class="token punctuation">,</span>SIGSYS<span class="token punctuation">,</span>SIGTERM<span class="token punctuation">,</span>SIGUSR1<span class="token punctuation">,</span>SIGUSR2<span class="token punctuation">,</span>SIGVTALRM
    
5、默认会导致进程停止的信号有：SIGSTOP<span class="token punctuation">,</span>SIGTSTP<span class="token punctuation">,</span>SIGTTIN<span class="token punctuation">,</span>SIGTTOU
    
6、默认进程忽略的信号有：SIGCHLD<span class="token punctuation">,</span>SIGPWR<span class="token punctuation">,</span>SIGURG<span class="token punctuation">,</span>SIGWINCH
    
7、此外，SIGIO在SVR4是退出，在4.3BSD中是忽略；SIGCONT在进程挂起时是继续，否则是忽略，不能被阻塞

</code></pre></div><h2 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h2> <p>需要引入头文件 thread</p> <p>https://www.zhihu.com/question/36236334</p> <h3 id="一些概念"><a href="#一些概念" class="header-anchor">#</a> 一些概念</h3> <p>多线程中一些概念词汇容易被误解，这里解释一下</p> <h4 id="核"><a href="#核" class="header-anchor">#</a> 核</h4> <p><strong>核</strong> ：指的是cpu芯片集成到 <strong>运算核心</strong> 模块。</p> <p><strong>单核</strong>：就是cpu集成单个运算核心</p> <p><strong>多核</strong>：就是多个运算核心，显然多核的运算能力更强。</p> <h4 id="并发"><a href="#并发" class="header-anchor">#</a> 并发</h4> <p>并发就是一段时间内<strong>来回执行不同的任务</strong>，同一时刻只能执行一个任务，但是将时间拆分很多分，每个任务轮流执行（如果有优先级，那么优先级高的任务将获取到更多时间，也优先被处理）</p> <h4 id="并行"><a href="#并行" class="header-anchor">#</a> 并行</h4> <p>并行是在多核cpu芯片下，同一时刻同时运行多个任务（并发并非真正多任务，它只是时间拆分细，看着像同时执行）。</p> <p>cpu集成单个运算核心模块越多，并行任务数越多，能力越强</p> <h4 id="多进程"><a href="#多进程" class="header-anchor">#</a> 多进程</h4> <p>系统将每个程序都单独分配了独立的内存空间</p> <p>操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据</p> <p>通常一个软件分配一个独立的进程，并有唯一的进程ID。除非你杀掉这个进程，否则其他程序无法分配这个进程ID。</p> <h4 id="进程间通讯"><a href="#进程间通讯" class="header-anchor">#</a> 进程间通讯</h4> <p>软件之间也可能存在业务交互需求，那么软件之间的通讯也就同 进程 之间相互通信一样，由于系统对进程间通信管理严格，通常需要使用系统指定的api。</p> <p>在进程间的通信，可以使用信号、套接字，文件、管道等方式，这个操作相对比较消耗资源，不适合大量高频任务</p> <h4 id="线程"><a href="#线程" class="header-anchor">#</a> 线程</h4> <p>一个程序至少一个进程，一个进程至少一个线程（主线）</p> <p>当一个程序启动时，就有<strong>一个进程</strong>被操作系统创建，与此同时<strong>一个线程</strong>也立刻运行，该线程通常叫作程序的<strong>主线程（Main Thread）</strong>。</p> <p>任何一个进程都包含一个主线程，只有主线程的进程称为<strong>单线程进程</strong>。</p> <p>线程是参与<strong>系统调度的最小单位</strong>。它被包含在进程中，是<strong>进程中的实际运行单位</strong>。一个线程指的是进程中一个单一顺序的<strong>控制流</strong>（或者说是执行路线、执行流），一个进程中可以创建多个线程，多个线程实现并发运行，每个线程执行不同的任务。</p> <p><strong>其它的线程通常由主线程创建</strong>，也称为主线程的子线程。所以<strong>主线程通常会在最后结束运行，执行各种清理工作</strong>（如为子线程收尸）。</p> <h4 id="多线程-2"><a href="#多线程-2" class="header-anchor">#</a> 多线程</h4> <p>多个系统任务调度逻辑单元，也就是多个任务被分配给多个任务调度员去管理，而不是一个管理员</p> <p>通常说的多线程都是只在某一个进程中的多个任务调度</p> <h3 id="创建线程"><a href="#创建线程" class="header-anchor">#</a> 创建线程</h3> <p>c++ 中引入线程库  thread</p> <p>示例：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">thread_call_me</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;子线程调用：&quot;</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;main：主线程\n&quot;</span><span class="token punctuation">;</span>
  
  thread <span class="token function">first</span> <span class="token punctuation">(</span>thread_call_me<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开启线程, 调用 thread_call_me</span>
  thread <span class="token function">second</span> <span class="token punctuation">(</span>thread_call_me<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开启线程</span>
  thread <span class="token function">third</span> <span class="token punctuation">(</span>thread_call_me<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// join：等待启动的线程执行完成，才会继续往下执行。</span>
  first<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  second<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  third<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  
  <span class="token comment">//必须join完成</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;子线程结束.\n&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果：</p> <div class="language-scss extra-class"><pre class="language-scss"><code>main：主线程
子线程调用：1
子线程调用：3
子线程调用：2
子线程结束.
</code></pre></div><h3 id="编译命令"><a href="#编译命令" class="header-anchor">#</a> 编译命令</h3> <p>不用环境和库在编译时都可能存在区别，需要根据情况处理，包括兼容性</p> <p><strong>本地运行</strong></p> <p>⚠️⚠️⚠️ 请添加编译参数 -lpthread 执行命令，否则会失败：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ g++ thread.cpp <span class="token parameter variable">-lpthread</span> <span class="token parameter variable">-o</span> thread.o
./thread.o

// 或

g++ test.cc <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">-l</span> pthread
</code></pre></div><p>⚠️⚠️⚠️ 如果你是在Mac 电脑系统运行，需要指定c++版本，因为从c++11以后才支持多线程</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ g++ <span class="token parameter variable">-std</span><span class="token operator">=</span>c++11 thread.cpp <span class="token parameter variable">-lpthread</span> <span class="token parameter variable">-o</span> thread.o
$ ./thread.o
</code></pre></div><p><strong>在线编译</strong>： https://www.onlinegdb.com</p> <p>⚠️⚠️⚠️ 其中设置选择 Command line arguments:  里 填 -lpthread</p> <h3 id="join与detach"><a href="#join与detach" class="header-anchor">#</a> join与detach</h3> <p>1、join方式，等待启动的线程完成，才会继续往下执行。</p> <p>2、detach方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。</p> <p>如果把上面示例中的相关修改：</p> <div class="language-scss extra-class"><pre class="language-scss"><code>first.<span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
second.<span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
third.<span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>删除两行，改为：</p> <div class="language-scss extra-class"><pre class="language-scss"><code>second.<span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>运行结果：</p> <div class="language-scss extra-class"><pre class="language-scss"><code>main：主线程
子线程调用：2
子线程结束.
terminate called without an active exception
</code></pre></div><p>显然部分子线程没有设置执行方式，程序出行异常</p> <p>如果不想等待，也需要写明，使用detach：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>first<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不需要等待该子线程</span>
second<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 需要等待子线程2执行完成</span>
third<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不需要等待该子线程</span>
</code></pre></div><p>结果：</p> <div class="language-scss extra-class"><pre class="language-scss"><code>main：主线程
子线程调用：3
子线程调用：1
子线程调用：2
��线程结束.

<span class="token comment">// 再试一次：</span>

main：主线程
子线程调用：2
子线程调用：3
子线程结束.
</code></pre></div><p>每次结果可能都不一样。但是至少 second thread 一定会执行完成。</p> <h3 id="this-thread"><a href="#this-thread" class="header-anchor">#</a> this_thread</h3> <p>this_thread是一个类，它有4个功能函数，具体如下：</p> <table><thead><tr><th>函数</th> <th>使用</th> <th>说明</th></tr></thead> <tbody><tr><td>get_id</td> <td>std::this_thread::get_id()</td> <td>获取线程id</td></tr> <tr><td>yield</td> <td>std::this_thread::yield()</td> <td>放弃线程执行，回到就绪状态</td></tr> <tr><td>sleep_for</td> <td>std::this_thread::sleep_for(std::chrono::seconds(1));</td> <td>暂停1秒</td></tr> <tr><td>sleep_until</td> <td>如下</td> <td>一分钟后执行吗，如下</td></tr></tbody></table> <p>使用前面的示例演示获取线程id：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">thread_call_me</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;子线程调用:&quot;</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;; 线程id = &quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;main：主线程&quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;; 线程id = &quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
  
  thread <span class="token function">first</span> <span class="token punctuation">(</span>thread_call_me<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开启线程, 调用 thread_call_me</span>
  thread <span class="token function">second</span> <span class="token punctuation">(</span>thread_call_me<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开启线程</span>
  thread <span class="token function">third</span> <span class="token punctuation">(</span>thread_call_me<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  
  first<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 需要等待该子线程</span>
  second<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 需要等待子线程2执行完成</span>
  third<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 需要等待该子线程  </span>

  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;子线程结束.\n&quot;</span><span class="token punctuation">;</span><span class="token comment">//必须join完成</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果（请添加编译参数 -lpthread 执行命令）</p> <div class="language-scss extra-class"><pre class="language-scss"><code>main：主线程<span class="token punctuation">;</span> 线程id = 140085890111296
子线程调用<span class="token punctuation">:</span>2<span class="token punctuation">;</span> 线程id = 140085881714240
子线程调用<span class="token punctuation">:</span>1<span class="token punctuation">;</span> 线程id = 140085890106944
子线程调用<span class="token punctuation">:</span>3<span class="token punctuation">;</span> 线程id = 140085873321536
子线程结束.
</code></pre></div><h2 id="锁-多线程"><a href="#锁-多线程" class="header-anchor">#</a> 锁（多线程）</h2> <p>1、常规互斥锁mutex可以使用lock对某一个子线程进行任务加锁，直到任务执行完成，加锁期间资源不会被其他线程修改，直到unlock。</p> <p>2、还有一种场景是有多个子线程，这些线程存在依赖关系，比如 一个线程需要等其他某些线程执行完成后再进行其他逻辑，这样单纯lock无法满足。那么可以使用condition_variable 和 condition_variable_any</p> <h3 id="互斥锁mutex"><a href="#互斥锁mutex" class="header-anchor">#</a> 互斥锁mutex</h3> <p>如下表所示。</p> <table><thead><tr><th>类型</th> <th>说明</th></tr></thead> <tbody><tr><td>std::mutex</td> <td>最基本的 Mutex 类。</td></tr> <tr><td>std::recursive_mutex</td> <td>递归 Mutex 类。</td></tr> <tr><td>std::time_mutex</td> <td>定时 Mutex 类。</td></tr> <tr><td>std::recursive_timed_mutex</td> <td>定时递归 Mutex 类。</td></tr></tbody></table> <p>std::mutex 是C++11 中最基本的互斥量，供了独占所有权的特性</p> <p>std::recursive_lock 则可以递归地对互斥量对象上锁。</p> <ul><li>lock()：资源上锁</li> <li>unlock()：解锁资源</li> <li>trylock()：查看是否上锁</li></ul> <h3 id="_1、lock与unlock"><a href="#_1、lock与unlock" class="header-anchor">#</a> 1、lock与unlock</h3> <p>mutex常用操作：</p> <ul><li>lock()：资源上锁</li> <li>unlock()：解锁资源</li> <li>trylock()：查看是否上锁</li></ul> <p>示例：</p> <p>1、多任务<strong>不加锁：</strong></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span> </span>

<span class="token keyword">void</span> <span class="token function">funpri</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
       <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟耗时操作</span>
       std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">th1</span> <span class="token punctuation">(</span>funpri<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token char">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//线程1：打印1</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">th2</span> <span class="token punctuation">(</span>funpri<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//线程2：打印0</span>

    th1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    th2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果：（程序并没有先打印10个1，然后10个0，而是乱序的）（请添加编译参数 -lpthread 执行命令）</p> <div class="language- extra-class"><pre class="language-text"><code>10101010101010101010
</code></pre></div><p>2、多任务<strong>加锁：</strong></p> <p>现在用一个互斥锁，所以第一个调用结束后才会执行下一次任务</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span>  <span class="token comment">// std::cout</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span>  <span class="token comment">// std::thread</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span>  <span class="token comment">// std::mutex</span></span>

std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>  <span class="token comment">// 声明互斥锁</span>
<span class="token keyword">void</span> <span class="token function">safe_fun</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加锁</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
       <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟耗时操作</span>
       std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">th1</span> <span class="token punctuation">(</span>safe_fun<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token char">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//线程1：打印1</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">th2</span> <span class="token punctuation">(</span>safe_fun<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//线程2：打印0</span>

    th1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    th2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：符合结果，先10个1，再10个0（请添加编译参数 -lpthread 执行命令）</p> <div class="language-text extra-class"><pre class="language-text"><code>11111111110000000000
</code></pre></div><h3 id="_2、lock-guard"><a href="#_2、lock-guard" class="header-anchor">#</a> 2、lock_guard</h3> <p><strong>作用域锁</strong>：加锁后不能手动unlock解锁，而是要等到加锁代码作用域结束自动解锁</p> <p>示例：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> g_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>mutex g_i_mutex<span class="token punctuation">;</span>  <span class="token comment">// protects g_i，用来保护g_i</span>

<span class="token keyword">void</span> <span class="token function">safe_fun</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>g_i_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加锁</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟耗时操作</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;; count = &quot;</span> <span class="token operator">&lt;&lt;</span> g_i <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>g_i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
    <span class="token comment">// 解锁代码不需要，这里加锁作用域结束会自动释放锁</span>
<span class="token punctuation">}</span>
 
 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;main id: &quot;</span> <span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;main: &quot;</span> <span class="token operator">&lt;&lt;</span> g_i <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>safe_fun<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>safe_fun<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;main: &quot;</span> <span class="token operator">&lt;&lt;</span> g_i <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Result: （请添加编译参数 -lpthread 执行命令）</p> <div class="language-scss extra-class"><pre class="language-scss"><code>main <span class="token property">id</span><span class="token punctuation">:</span> 140505467811648
<span class="token property">main</span><span class="token punctuation">:</span> 0
140505467807296<span class="token punctuation">;</span> count = 0
140505467807296<span class="token punctuation">;</span> count = 1
140505467807296<span class="token punctuation">;</span> count = 2
140505467807296<span class="token punctuation">;</span> count = 3
140505467807296<span class="token punctuation">;</span> count = 4

140505459414592<span class="token punctuation">;</span> count = 5
140505459414592<span class="token punctuation">;</span> count = 6
140505459414592<span class="token punctuation">;</span> count = 7
140505459414592<span class="token punctuation">;</span> count = 8
140505459414592<span class="token punctuation">;</span> count = 9

<span class="token property">main</span><span class="token punctuation">:</span> 10
</code></pre></div><h3 id="_3、unique-lock"><a href="#_3、unique-lock" class="header-anchor">#</a> 3、unique_lock</h3> <p>unique_lock：</p> <p>1、可加锁</p> <p>2、可以创建的时候不加锁，稍后再加锁</p> <p>3、可解锁</p> <p>4、作用域结束后自动解锁</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> g_i_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>mutex g_i_mutex<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">safe_fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// defer_lock: unlock，默认自动加锁</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock1</span><span class="token punctuation">(</span>g_i_mutex<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>defer_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    lock1<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 多个使用 std::lock(lock1, lock2);</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟耗时操作</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;; g_i_1 = &quot;</span> <span class="token operator">&lt;&lt;</span> g_i_1  <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>g_i_1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>safe_fun<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>safe_fun<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>result：（请添加编译参数 -lpthread 执行命令）</p> <div class="language-scss extra-class"><pre class="language-scss"><code>139727387924032<span class="token punctuation">;</span> g_i_1 = 0
139727387924032<span class="token punctuation">;</span> g_i_1 = 1
139727387924032<span class="token punctuation">;</span> g_i_1 = 2
139727379531328<span class="token punctuation">;</span> g_i_1 = 3
139727379531328<span class="token punctuation">;</span> g_i_1 = 4
139727379531328<span class="token punctuation">;</span> g_i_1 = 5
</code></pre></div><h3 id="死锁"><a href="#死锁" class="header-anchor">#</a> 死锁</h3> <p><strong>1、死锁的形成场景：</strong></p> <p>1）忘记释放锁：在申请锁和释放锁之间直接return</p> <p>2）单线程重复申请锁：一个线程，刚出临界区，又去申请资源。</p> <p>3）多线程多锁申请：两个线程，两个锁，他们都已经申请了一个锁了，都想申请对方的锁</p> <p>4）环形锁的申请：多个线程申请锁的顺序形成相互依赖的环形</p> <p><strong>2、产生死锁的必要条件：</strong></p> <p>1）互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</p> <p>2）请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p> <p>3）不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p> <p>4）环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</p> <p><strong>3、解决死锁的基本方法：</strong></p> <p>1）一次性分配完所有资源，这样就不会再有请求了：（破坏请求条件）</p> <p>2）当进程阻塞时，释放所持有的资源（破坏请保持条件）</p> <p>3）资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p> <h2 id="条件变量-线程"><a href="#条件变量-线程" class="header-anchor">#</a> 条件变量（线程）</h2> <p>文件定义：</p> <p>https://www.apiref.com/cpp-zh/cpp/header/condition_variable.html</p> <p><strong>condition_variable</strong> ：</p> <p>1、必须结合unique_lock使用</p> <p>2、条件变量可以阻塞（wait、wait_for、wait_until）调用的线程直到使用（notify_one或notify_all）通知恢复为止。</p> <p>3、是一个类，这个类既有构造函数也有析构函数，使用时需要构造对应的condition_variable对象，调用对象相应的函数来实现上面的功能。</p> <p><strong>condition_variable_any</strong> ：</p> <p>condition_variable_any可以使用任何的锁，mutex 即可。</p> <table><thead><tr><th>类型</th> <th>说明</th></tr></thead> <tbody><tr><td>condition_variable</td> <td>构建对象</td></tr> <tr><td>析构</td> <td>删除</td></tr> <tr><td>wait</td> <td>Wait until notified</td></tr> <tr><td>wait_for</td> <td>Wait for timeout or until notified</td></tr> <tr><td>wait_until</td> <td>Wait until notified or time point</td></tr> <tr><td>notify_one</td> <td>解锁一个线程，如果有多个，则未知哪个线程执行</td></tr> <tr><td>notify_all</td> <td>解锁所有线程</td></tr> <tr><td>cv_status</td> <td>这是一个类，表示variable 的状态，如下所示</td></tr></tbody></table> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">cv_status</span> <span class="token punctuation">{</span> no_timeout<span class="token punctuation">,</span> timeout <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_1、wait"><a href="#_1、wait" class="header-anchor">#</a> 1、wait</h3> <p>实现一个功能：任务A 依赖任务B、C、D都完成后再执行， 其中 B、C、D 可乱序</p> <p><strong>代码示例：</strong></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span>           <span class="token comment">// std::cout</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span>             <span class="token comment">// std::thread, std::this_thread::yield</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span>              <span class="token comment">// std::mutex, std::unique_lock</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span> <span class="token comment">// std::condition_variable</span></span>

std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span> <span class="token comment">// 互斥锁</span>
std<span class="token double-colon punctuation">::</span>condition_variable cv<span class="token punctuation">;</span> <span class="token comment">// 条件变量（信号）通知能力</span>

<span class="token keyword">int</span> semaphore_num <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 信号量（标记状态, 大于0时阻塞线程）</span>

<span class="token comment">// 判断当前是否阻塞线程（wait 需要使用此函数作参数）</span>
<span class="token keyword">bool</span> <span class="token function">shipment_available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> semaphore_num<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">// 任务函数，每次执行后信号量-1</span>
<span class="token keyword">void</span> <span class="token function">work_s</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> t<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lck</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    semaphore_num<span class="token operator">-=</span><span class="token number">1</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;执行任务 &quot;</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>

    cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 任务通知，最后执行的任务，当状态非阻塞时执行任务</span>
<span class="token keyword">void</span> <span class="token function">work_notify</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> t<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lck</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动上锁</span>
    
    <span class="token comment">//第二个参数为false才阻塞（wait），阻塞完即unlock，给其它线程资源</span>
    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lck<span class="token punctuation">,</span>shipment_available<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;最后执行的任务：&quot;</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;主线程开始执行&quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>

    <span class="token comment">// 线程任务，最后执行的，依赖下面其他任务执行完成</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_a</span> <span class="token punctuation">(</span>work_notify<span class="token punctuation">,</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 其他子线程任务</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_b</span> <span class="token punctuation">(</span>work_s<span class="token punctuation">,</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_c</span> <span class="token punctuation">(</span>work_s<span class="token punctuation">,</span> <span class="token string">&quot;C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_d</span> <span class="token punctuation">(</span>work_s<span class="token punctuation">,</span> <span class="token string">&quot;D&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;主线程执行的其它同步任务1&quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>

    thread_a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// join 阻塞当前主线程</span>
    thread_b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread_c<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread_d<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;主线程结束任务&quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果：（请添加编译参数 -lpthread 执行命令）</p> <div class="language- extra-class"><pre class="language-text"><code>主线程开始执行
执行任务 C
主线程执行的其它同步任务1
执行任务 D
执行任务 B
最后执行的任务：A
主线程结束任务

</code></pre></div><p>代码解析：</p> <div class="language-scss extra-class"><pre class="language-scss"><code><span class="token comment">// 简单说就是b,c,d 三个任务执行完成后发送的通知告诉wait()，如果号量=0时，表示不用等待了</span>

1、thread_a 线程要执行work_notify函数时，<span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>会先判断当前是否在阻塞中，直到非阻塞才执行任务

2、thread_b、thread_c、thread_d 每次执行任务时，都会将信号量-1，直到信号量=0时，
cv.notify_<span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 会发送一个到thread_a 中的<span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 状态变更的通知，告诉它状态变更

3、信号量=0非阻塞时，执行work_notify函数中任务
</code></pre></div><h3 id="_2、wait-for"><a href="#_2、wait-for" class="header-anchor">#</a> 2、wait_for</h3> <p>前面wait中介绍到，任务B、C、D都完成后再执行A，但是有一种情况，任务B、C、D 中存在某个任务请求超时了，那么就永远无法通知到A执行任务了。</p> <p>这样就会影响后面的程序功能了。</p> <p><strong>wait_for</strong></p> <p>与std::condition_variable::wait() 类似，不过 wait_for 增加了<strong>超时</strong>判断：</p> <p>示例1：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span>           <span class="token comment">// std::cout</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span>             <span class="token comment">// std::thread, std::this_thread::yield</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span>              <span class="token comment">// std::mutex, std::unique_lock</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span> <span class="token comment">// std::condition_variable</span></span>

std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span> <span class="token comment">// 互斥锁</span>
std<span class="token double-colon punctuation">::</span>condition_variable cv<span class="token punctuation">;</span> <span class="token comment">// 条件变量（信号）通知能力</span>
cv_status 
<span class="token keyword">int</span> semaphore_num <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 信号量（标记状态, 大于0时阻塞线程）</span>

<span class="token comment">// 判断当前是否阻塞线程（wait 需要使用此函数作参数）</span>
<span class="token keyword">bool</span> <span class="token function">shipment_available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> semaphore_num<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">// 任务函数，每次执行后信号量-1</span>
<span class="token keyword">void</span> <span class="token function">work_s</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> t<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lck</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    semaphore_num<span class="token operator">-=</span><span class="token number">1</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;执行任务 &quot;</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>

    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟延时任务</span>
    
    <span class="token comment">// 子任务执行完成后，如果不需要阻塞，发出通知</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>shipment_available<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

<span class="token comment">// 任务通知，最后执行的任务，当状态非阻塞时执行任务</span>
<span class="token keyword">void</span> <span class="token function">work_notify</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> t<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lck</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动上锁</span>
    
    std<span class="token double-colon punctuation">::</span>cv_status status <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lck<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置5秒超时，超时后会走 timeout</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>cv_status<span class="token double-colon punctuation">::</span>timeout<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//表示线程还没执行完，此时已经超时了</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;子线程任务超时，线程还没有执行完毕，当前任务 &quot;</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; 被弃&quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>cv_status<span class="token double-colon punctuation">::</span>no_timeout<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//表示线程成功返回</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;其他子线程全部执行完毕&quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;最后执行的任务：&quot;</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 线程任务，最后执行的，依赖下面其他任务执行完成</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_a</span> <span class="token punctuation">(</span>work_notify<span class="token punctuation">,</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 其他子线程任务</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_b</span> <span class="token punctuation">(</span>work_s<span class="token punctuation">,</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_c</span> <span class="token punctuation">(</span>work_s<span class="token punctuation">,</span> <span class="token string">&quot;C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_d</span> <span class="token punctuation">(</span>work_s<span class="token punctuation">,</span> <span class="token string">&quot;D&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    thread_a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread_b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread_c<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread_d<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>结果：</strong>（设置3个任务每次1秒，设置5秒的timeout，所以当前任务正常执行了）</p> <div class="language- extra-class"><pre class="language-text"><code>执行任务 C
执行任务 D
执行任务 B
其他子线程全部执行完毕
最后执行的任务：A
</code></pre></div><p><strong>修改</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>
    std::cv_status status = cv.wait_for(lck,std::chrono::seconds(2)); // 设置2秒超时，超时后会走 timeout

</code></pre></div><p><strong>结果：</strong>（设置3个任务每次1秒，设置2秒的timeout，所以当前任务正常执行了）</p> <div class="language- extra-class"><pre class="language-text"><code>执行任务 C
执行任务 D
执行任务 B
子线程任务超时，线程�没有执行完毕，当前任务 A 被弃

</code></pre></div><p>示例2: 使用future</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//  ⚠️ async 异步函数， 不会阻塞当前主线程</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// std::future&lt;int&gt; result = std::async(std::launch::deferred, mythread);</span>
    
    <span class="token comment">// ⚠️ wait_for （未设置async第一参数状态）阻塞当前主线程</span>
    std<span class="token double-colon punctuation">::</span>future_status status <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>timeout<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;任务超时，线程还没有执行完毕&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>ready<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;线程成功执行完毕&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>deferred<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//如果async的第一个参数被设置为std::launch::deferred，立即执行此次，表示默认状态已设置</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;任务延迟执行!&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;main全部任务结束！&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果</p> <div class="language- extra-class"><pre class="language-text"><code>任务超时，线程还没有执行完毕
main全部任务结束！
</code></pre></div><h2 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <p>在一个程序中，如果我们需要多次使用线程，这就意味着，需要多次的创建并销毁线程。而创建并销毁线程的过程势必会消耗内存，线程过多会带来调动的开销，进而影响缓存局部性和整体性能。线程的创建并销毁有以下一些缺点：</p> <ul><li>创建太多线程，将会浪费一定的资源，有些线程未被充分使用。</li> <li>销毁太多线程，将导致之后浪费时间再次创建它们。</li> <li>创建线程太慢，将会导致长时间的等待，性能变差。</li> <li>销毁线程太慢，导致其它线程资源饥饿。</li></ul> <p>线程池维护着多个线程，这避免了在处理短时间任务时，创建与销毁线程的代价。</p> <h3 id="线程池的实现"><a href="#线程池的实现" class="header-anchor">#</a> 线程池的实现</h3> <p>⚠️ 程序开发过程中，池 的概念很重要，程序要需要在在有限的资源中 考虑 预加载、重复利用、优化性能等</p> <p>线程池：程序边运行边创建线程是比较耗时的，线程被使用前提前创建适量的数量线程备用，这样，程序在运行时，只需要从线程池中拿来用就可以了．大大提高了程序运行效率．一般线程池都会有以下几个部分构成：</p> <ol><li>线程池管理器（ThreadPoolManager）:用于创建并管理线程池，也就是线程池类</li> <li>工作线程（WorkThread）: 线程池中线程</li> <li>任务队列task: 用于存放没有处理的任务。提供一种缓冲机制。</li> <li>append：用于添加任务的接口</li></ol> <p>线程池实现代码：<a href="https://mp.weixin.qq.com/s?__biz=MzA3NzI1Njk1MQ==&amp;mid=2648577488&amp;idx=1&amp;sn=8889e18fbe87f0a0dc4077c77f096098&amp;chksm=877e7448b009fd5efa860edc0a94550df6a08dfb2cb3206ae3ef32f5ff244bde41b7df3b595c&amp;scene=27" target="_blank" rel="noopener noreferrer">线程池代码链接,实测运行正常<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
 
<span class="token keyword">const</span> <span class="token keyword">int</span> MAX_THREADS <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">//最大线程数目</span>
 
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">threadPool</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">threadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">threadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">append</span><span class="token punctuation">(</span>T <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//工作线程需要运行的函数,不断的从任务队列中取出并执行</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">worker</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">//工作线程</span>
    vector<span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span> workThread<span class="token punctuation">;</span>
    <span class="token comment">//任务队列</span>
    queue<span class="token operator">&lt;</span>T <span class="token operator">*</span><span class="token operator">&gt;</span> taskQueue<span class="token punctuation">;</span>
    mutex mt<span class="token punctuation">;</span>
    condition_variable condition<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> stop<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token class-name">threadPool</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">threadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> number <span class="token operator">&gt;</span> MAX_THREADS<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token function">exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> number<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;create thread：&quot;</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        workThread<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>worker<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">inline</span> threadPool<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">threadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">unique</span><span class="token punctuation">(</span>mt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    condition<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>wt <span class="token operator">:</span> workThread<span class="token punctuation">)</span>
        wt<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">threadPool</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">append</span><span class="token punctuation">(</span>T <span class="token operator">*</span>task<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//往任务队列添加任务的时候，要加锁，因为这是线程池，肯定有很多线程</span>
    unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">unique</span><span class="token punctuation">(</span>mt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    taskQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    unique<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//任务添加完之后，通知阻塞线程过来消费任务，有点像生产消费者模型</span>
    condition<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token class-name">threadPool</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">worker</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    threadPool <span class="token operator">*</span>pool <span class="token operator">=</span> <span class="token punctuation">(</span>threadPool <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
    pool<span class="token operator">-&gt;</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> pool<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">threadPool</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stop<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">unique</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>mt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果任务队列为空，就停下来等待唤醒，等待另一个线程发来的唤醒请求</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>taskQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">this</span><span class="token operator">-&gt;</span>condition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>unique<span class="token punctuation">)</span><span class="token punctuation">;</span>      
        T <span class="token operator">*</span>task <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>taskQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>taskQueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">)</span>
            task<span class="token operator">-&gt;</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 以下是实现部分
 * */</span> 


<span class="token keyword">class</span> <span class="token class-name">Task</span>
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token comment">// 任务</span>
<span class="token keyword">void</span> <span class="token class-name">Task</span><span class="token double-colon punctuation">::</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;任务执行完成 ！&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">std</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">queue</span><span class="token operator">&lt;</span><span class="token class-name">Task</span><span class="token operator">&gt;</span></span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    threadPool<span class="token operator">&lt;</span>Task<span class="token operator">&gt;</span> <span class="token function">pool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Task <span class="token operator">*</span>task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pool<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">delete</span> task<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>运行：</p> <div class="language-scss extra-class"><pre class="language-scss"><code>create thread：0
任务执行完成 ！
任务执行完成 ！
任务执行完成 ！
任务执行完成 ！
任务执行完成 ！
任务执行完成 ！
^C

...Program finished <span class="token module-modifier keyword">with</span> exit code 0
Press ENTER to exit console.
</code></pre></div><h2 id="cgi"><a href="#cgi" class="header-anchor">#</a> CGI</h2> <p>基于CGI 您可以用于 客户端 <strong>动态</strong> 请求 服务器端资源 (如,HTML页面/二进制文件)</p> <p>比如GET、POST等的实现</p> <p>在CGI的基础上作了进一步包装的 CSP/ASP/JSP/PHP/PERL</p> <p>等等</p> <h3 id="什么是cgi"><a href="#什么是cgi" class="header-anchor">#</a> 什么是CGI</h3> <p>CGI 是通用网关接口(Common Gateway Interface)的缩写. 它主要用于服务器端动态输出客户端的请求(如,HTML页面/二进制文件).</p> <p>客户端请求参数不同, 服务器端会给出不同的应答结果</p> <p>CGI 标准将这个接口定义的非常简单 (即: WEB 服务器收到客户端的请求后通过环境变量和标准输入(stdin)将数据传递给CGI程序, CGI程序通过标准输出(stdout) 将数据返回给客户端). 所以只要能操作标准输入/输出的程序语言都可以CGI程序, Perl/C++/JAVA/VB等.</p> <p><strong>CSP/ASP/JSP/PHP/PERL</strong> 与CGI程序的关系?
它们大都是CGI的变种, 因为它们的操作原理都是CGI的基础上作了进一步的包装, 屏蔽了CGI的与程序语言相关的接口.</p> <p><strong>为什么还直接用CGI呢?</strong>
1、高效率：</p> <p>C/C++ 不像PERL/VBS/JS等解释执行语言运行时解释执行源文件中的语句. 同时这一点仍非JAVA/PHP等所能及. 所以C/C++仍是许多WEB应用的首选, 特点是大型WEB应用中.</p> <p>2、兼容性：</p> <p>嵌入式设备(如PDA/数码产品/通信产品)WEB应用的首选, 目前几乎所有的嵌入式设备都直接用C语言开发, 而CPU/内存/外存等的限制几乎根本不可能安装如PERL/ASP/JSP的运行环境, 所以嵌入式设备上C开发CGI几乎仍是唯一选择.</p> <p><strong>将 C 直接嵌入到HTML中叫CSP吗?</strong>
是的, C 语言天然好的&quot;移植性/高效性/灵活性&quot;, 一直以来都是最受程序员青睐的语言, 现在用CSP 技术我们就可以轻松地将 C 语句直接嵌入到 HTML 源文件中了, 它编程过程跟ASP/JSP/PHP 几乎一样. 甚至有些时候, 就可以直接拿 JSP/PHP 的源文件作为 CSP 的源文件了, 因为它们都用 &lt;% 和 %&gt; 进行标记.</p></div></div> <!----> <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/0b5e9c/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">C++高级教程(中)</div></a> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/0b5e9c/" class="prev">C++高级教程(中)</a></span> <!----></p></div></div></div> <!----></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.882bfa45.js" defer></script><script src="/assets/js/2.d54d51d6.js" defer></script><script src="/assets/js/83.a593fa84.js" defer></script>
  </body>
</html>
