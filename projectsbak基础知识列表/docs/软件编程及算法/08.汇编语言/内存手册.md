# 介绍



内存是所有程序都会使用的重要系统资源。程序必须先加载到内存中，然后才能运行，并且在运行时，它们会分配额外的内存（显式和隐式）来存储和操作程序级数据。在内存中为程序的代码和数据腾出空间需要时间和资源，因此会影响系统的整体性能。尽管您无法完全避免使用内存，但有一些方法可以最大限度地减少内存使用对系统其他部分的影响。



本文档提供有关 OS X 和 iOS 内存系统以及如何有效使用它们的背景信息。您可以使用此信息来调整程序的内存使用情况，确保在正确的时间分配正确的内存量。本文档还提供了有关如何检测程序中与内存相关的性能问题的提示。



## 本文件的组织结构

本编程主题包括以下文章：

- [关于虚拟内存系统](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html#//apple_ref/doc/uid/20001880-BCICIHAB)介绍了术语并提供了 OS X 和 iOS 虚拟内存系统的高级概述。
- [分配内存的技巧](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MemoryAlloc.html#//apple_ref/doc/uid/20001881-CJBCFDGA)描述了分配、初始化和复制内存的最佳技术。它还描述了在 iOS 中响应低内存通知的正确方法。
- [缓存和可清除内存](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/CachingandPurgeableMemory.html#//apple_ref/doc/uid/TP40013104-SW1)讨论了缓存的好处，以及如何避免实现缓存时可能出现的一些问题。它还详细介绍了在缓存系统中实现可清除内存的优点以及如何成功实现这项有益的技术。
- [跟踪内存使用情况](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingPatterns.html#//apple_ref/doc/uid/20001882-CJBJFIDD)描述了用于分析应用程序内存使用情况的工具和技术。
- [查找内存泄漏](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingLeaks.html#//apple_ref/doc/uid/20001883-CJBJFIDD)描述了用于查找应用程序中内存泄漏的工具和技术。
- [启用 Malloc 调试功能](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html#//apple_ref/doc/uid/20001884-CJBJFIDD)描述了用于启用 malloc 历史记录的环境变量。在使用某些内存分析工具之前，您必须设置其中一些变量。
- [查看虚拟内存使用情况](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/VMPages.html#//apple_ref/doc/uid/20001985-CJBJFIDD)描述了用于分析应用程序内存占用的工具和技术。

[下一个](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html)



# 关于虚拟内存系统

高效的内存管理是在 OS X 和 iOS 中编写高性能代码的一个重要方面。最大限度地减少内存使用不仅可以减少应用程序的内存占用量，还可以减少其消耗的 CPU 时间。不过，为了正确调整代码，您需要了解底层系统如何管理内存。

OS X 和 iOS 都包含一个完全集成的虚拟内存系统，您无法关闭该系统；它始终开启。两个系统还为每个 32 位进程提供高达 4 GB 的可寻址空间。此外，OS X 为 64 位进程提供大约 18 艾字节的可寻址空间。即使对于具有 4 GB 或更多可用 RAM 的计算机，系统也很少将这么多 RAM 专门用于单个进程。

为了让进程能够访问其整个 4 GB 或 18 艾字节地址空间，OS X 使用硬盘来保存当前未使用的数据。当内存变满时，未使用的内存部分将写入磁盘，为现在需要的数据腾出空间。磁盘中存储未使用数据的部分称为后备存储，因为它为主内存提供备份存储。

尽管 OS X 支持后备存储，但 iOS 不支持。在 iPhone 应用程序中，磁盘上已有的只读数据（例如代码页）只需从内存中删除，并根据需要从磁盘重新加载。操作系统永远不会从内存中删除可写数据。相反，如果可用内存量下降到某个阈值以下，系统会要求正在运行的应用程序自动释放内存，为新数据腾出空间。无法释放足够内存的应用程序将被终止。



**注意：** 与大多数基于 UNIX 的操作系统不同，OS X 不使用预分配的磁盘分区作为后备存储。相反，它使用计算机启动分区上的所有可用空间。



以下各节介绍术语并简要概述 OS X 和 iOS 中使用的虚拟内存系统。有关虚拟内存系统如何工作的更多详细信息，请参阅*[内核编程指南](https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/About/About.html#//apple_ref/doc/uid/TP30000905)*。



## 关于虚拟内存

虚拟内存允许操作系统摆脱物理 RAM 的限制。虚拟内存管理器创建一个逻辑地址空间（或“每个进程的“虚拟”地址空间）并将其划分为大小统一的内存块，称为*页面*。处理器及其内存管理单元（MMU）维护一个*页表*将程序逻辑地址空间中的页面映射到计算机 RAM 中的硬件地址。当程序代码访问内存中的地址时，MMU 使用页表将指定的逻辑地址转换为实际的硬件内存地址。这种转换是自动发生的，并且对于正在运行的应用程序是透明的。

对于程序而言，其逻辑地址空间中的地址始终可用。但是，如果应用程序访问当前不在物理 RAM 中的内存页上的地址，*发生页面错误*。当这种情况发生时，虚拟内存系统会调用一个特殊的页面错误处理程序来立即响应该错误。页面错误处理程序停止当前正在执行的代码，找到物理内存的空闲页面，从磁盘加载包含所需数据的页面，更新页表，然后将控制权返回给程序代码，程序代码可以访问内存地址通常情况下。这个过程被称为*寻呼*。

如果物理内存中没有可用的空闲页面，则处理程序必须首先释放现有页面以为新页面腾出空间。系统如何发布页面取决于平台。在 OS X 中，虚拟内存系统经常将页面写入后备存储。这*后备存储*是基于磁盘的存储库，其中包含给定进程使用的内存页的副本。将数据从物理内存移动到后备存储称为*调出*（或“交换出”）；将数据从后备存储移回物理内存称为*分页*（或“交换”）。在 iOS 中，没有后备存储，因此页面永远不会调出到磁盘，但只读页面仍会根据需要从磁盘调入。

在 OS X 和早期版本的 iOS 中，页面的大小是 4 KB。在更高版本的 iOS 中，基于 A7 和 A8 的系统向由 4 KB 物理页支持的 64 位用户空间公开 16 KB 页面，而 A9 系统公开由 16 KB 物理页支持的 16 KB 页面。这些大小决定了发生页面错误时系统从磁盘读取多少KB。当系统花费过多的时间处理页面错误以及读写页面而不是执行程序代码时，就会发生*磁盘抖动。*

任何类型的分页，尤其是磁盘抖动，都会对性能产生负面影响，因为它迫使系统花费大量时间读取和写入磁盘。从后备存储读取页面需要花费大量时间，并且比直接从 RAM 读取要慢得多。如果系统必须先将一页写入磁盘，然后才能从磁盘读取另一页，则性能影响会更严重。



## 虚拟内存系统的详细信息

进程的逻辑地址空间由内存的映射区域组成。每个映射的内存区域包含已知数量的虚拟内存页。每个区域都有特定的属性来控制诸如继承（区域的一部分可以从“父”区域映射）、写保护以及是否连线*（*即，它不能被调出）等操作。由于区域包含已知数量的页面，因此它们是*page-aligned*，意味着区域的起始地址也是页面的起始地址，结束地址也定义页面的结束。

内核关联一个*虚拟机对象*与逻辑地址空间的每个区域。内核使用VM对象来跟踪和管理相关区域的驻留和非常驻页面。区域可以映射到后备存储的一部分或文件系统中的内存映射文件。每个VM对象都包含一个映射，该映射将区域与默认分页器或vnode分页器关联起来。这*默认分页器*是一个系统管理器，它管理后备存储中的非常驻虚拟内存页面并在请求时获取这些页面。这*vnode寻呼机*实现内存映射文件访问。vnode 分页器使用分页机制提供直接进入文件的窗口。此机制使您可以读取和写入文件的部分内容，就像它们位于内存中一样。

除了将区域映射到默认或虚拟节点分页器之外，VM对象还可以将区域映射到另一个VM对象。内核使用这种自引用技术来实现*写时复制*区域。写时复制区域允许不同的进程（或进程中的多个代码块）共享一个页面，只要它们都不写入该页面。当进程尝试写入页面时，会在执行写入的进程的逻辑地址空间中创建该页面的副本。从那时起，写入过程将维护自己单独的页面副本，可以随时写入该副本。写时复制区域使系统能够在内存中有效地共享大量数据，同时仍然允许进程在需要时直接（安全地）操作这些页面。这些类型的区域最常用于从系统框架加载的数据页。

每个VM对象包含多个字段，如表1所示。



| 场地     | 描述                                           |
| :------- | :--------------------------------------------- |
| 常驻页面 | 当前驻留在物理内存中的该区域的页面列表。       |
| 尺寸     | 该区域的大小（以字节为单位）。                 |
| 寻呼机   | 寻呼机负责在后备存储中跟踪和处理该区域的页面。 |
| 阴影     | 用于写时复制优化。                             |
| 复制     | 用于写时复制优化。                             |
| 属性     | 指示各种实现细节状态的标志。                   |

如果 VM 对象涉及写时复制 ( `vm_copy`)操作时，影子和复制字段可能指向其他VM对象。否则两个字段通常都是`NULL`.



## 有线内存

有线内存（也称为*常驻*内存）存储绝不能分页到磁盘的内核代码和数据结构。应用程序、框架和其他用户级软件无法分配有线内存。然而，它们可以影响任何时候存在的有线内存量。例如，创建线程和端口的应用程序会为与其关联的所需内核资源隐式分配有线内存。

表 2列出了应用程序生成的实体的一些有线内存成本。



| 资源     | 内核使用的有线内存                 |
| :------- | :--------------------------------- |
| 过程     | 16 KB                              |
| 线       | 连续阻塞——5 KB；被阻止 — 21 KB     |
| 马赫端口 | 116字节                            |
| 测绘     | 32字节                             |
| 图书馆   | 2 KB 加上每个使用它的任务 200 字节 |
| 内存区域 | 160字节                            |



**注意：** 这些测量值可能会随着操作系统的每个新版本而变化。此处提供它们是为了让您粗略估计系统资源使用的相对成本。



正如您所看到的，每个线程、进程和库都会影响系统的驻留足迹。然而，除了使用有线内存的应用程序之外，内核本身还需要用于以下实体的有线内存：

- 虚拟机对象
- 虚拟内存缓冲区高速缓存
- I/O 缓冲区高速缓存
- 司机

有线数据结构还与用于存储虚拟内存映射信息的物理页和映射表相关联。这两个实体都随可用物理内存量而扩展。因此，当您向系统添加内存时，即使没有其他变化，有线内存的数量也会增加。当计算机首次启动到 Finder 且没有运行任何其他应用程序时，有线内存可能会消耗大约 64 兆字节系统中的 14 兆字节和 128 兆字节系统中的 17 兆字节。

当有线内存页面变得无效时，不会立即移回空闲列表。相反，当空闲页面计数低于触发页面调出事件的阈值时，它们将被“垃圾收集”。



## 内核中的页面列表

内核维护和查询三个系统范围的物理内存页列表：

- *活动列表*包含当前映射到内存中并且最近被访问过的页面。
- *非活动列表*包含当前驻留在物理内存中但最近未被访问过的页面。这些页面包含有效数据，但可能随时从内存中删除。
- 空闲*列表*包含不与VM对象的任何地址空间关联的物理内存页面。这些页面可供任何需要它们的进程立即使用。

当空闲列表上的页数低于阈值（由物理内存的大小确定）时，分页器会尝试平衡队列。它通过从非活动列表中提取页面来实现此目的。如果最近访问过某个页面，则会重新激活该页面并将其放置在活动列表的末尾。在 OS X 中，如果非活动页面包含最近未写入后备存储的数据，则必须先将其内容调出到磁盘，然后才能将其放入空闲列表。（在 iOS 中，已修改但不活动的页面必须保留在内存中，并由拥有它们的应用程序清除。）如果不活动页面尚未修改且不是永久驻留（连线），则它会被窃取（任何当前的虚拟映射到它被销毁）并添加到空闲列表中。一旦空闲列表大小超过目标阈值，寻呼机就会停止。

如果页面不被访问，内核会将页面从活动列表移动到非活动列表；它会在发生软故障时将页面从非活动列表移动到活动列表（请参阅[进行中的分页](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html#//apple_ref/doc/uid/20001880-99598)）。当虚拟页被换出时，相关的物理页被放置在空闲列表中。此外，当进程显式释放内存时，内核会将受影响的页面移至空闲列表。



## 调出流程

在 OS X 中，当空闲列表中的页面数量低于计算的阈值时，内核通过将不活动页面交换出内存来回收空闲列表的物理页面。为此，内核会迭代活动列表和非活动列表中的所有驻留页面，执行以下步骤：

1. 如果活动列表中的页面最近没有被触摸过，则会将其移至非活动列表。
2. 如果最近未触及非活动列表中的页面，则内核会找到该页面的 VM 对象。
3. 如果VM对象以前从未被分页，则内核调用初始化例程来创建并分配默认分页器对象。
4. VM 对象的默认分页器尝试将页面写入后备存储。
5. 如果分页成功，内核会释放该页面占用的物理内存，并将该页面从非活动列表移至空闲列表。



**注意：** 在 iOS 中，内核不会将页面写入后备存储。当可用内存量低于计算的阈值时，内核会刷新不活动且未修改的页面，并且还可能要求正在运行的应用程序直接释放内存。有关响应这些通知的更多信息，请参阅[响应 iOS 中的低内存警告](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MemoryAlloc.html#//apple_ref/doc/uid/20001881-SW1)。





## 寻呼正在进行中

虚拟内存管理的最后阶段将页面从后备存储或包含页面数据的文件移动到物理内存中。内存访问错误启动页面调入过程。当代码尝试访问未映射到物理内存的虚拟地址处的数据时，就会发生内存访问错误。故障有两种：

- 当引用地址的页面驻留在物理内存中但当前未映射到该进程的地址空间时，就会发生*软故障*。
- 当引用地址的页面不在物理内存中但被换出到后备存储（或可从映射文件中获取）时，就会发生*硬故障*。这就是通常所说的页面错误。

当任何类型的故障发生时，内核都会定位所访问区域的映射条目和VM对象。然后内核会遍历VM对象的常驻页面列表。如果所需的页面位于常驻页面列表中，则内核会生成软故障。如果该页面不在常驻页面列表中，则会生成硬故障。

对于软故障，内核将包含页面的物理内存映射到进程的虚拟地址空间。然后内核将特定页面标记为活动页面。如果故障涉及写入操作，该页面也会被标记为已修改，以便在稍后需要释放时将其写入后备存储。

对于硬故障，VM 对象的分页器会在后备存储中或从磁盘上的文件中查找页面，具体取决于分页器的类型。对映射信息进行适当的调整后，分页器将页面移动到物理内存中并将页面放置在活动列表中。与软故障一样，如果故障涉及写入操作，则该页将被标记为已修改。





# 分配内存的技巧

内存是应用程序的重要资源，因此考虑应用程序将如何使用内存以及什么可能是最有效的分配方法非常重要。大多数应用程序不需要做任何特殊的事情；他们可以简单地根据需要分配对象或内存块，而不会看到任何性能下降。然而，对于使用大量内存的应用程序，仔细规划内存分配策略可能会产生很大的不同。

以下各节介绍了分配内存的基本选项以及有效分配内存的技巧。要首先确定您的应用程序是否存在内存性能问题，您需要使用 Xcode 工具在应用程序运行时查看应用程序的分配模式。有关如何执行此操作的信息，请参阅[跟踪内存使用情况](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingPatterns.html#//apple_ref/doc/uid/20001882-CJBJFIDD)。



## 提高内存相关性能的技巧

在设计代码时，您应该始终了解如何使用内存。由于内存是一种重要的资源，因此您需要确保有效地使用它而不是浪费。除了为给定操作分配正确的内存量之外，以下各节还介绍了提高程序内存使用效率的其他方法。



### 推迟内存分配

每次内存分配都会产生性能成本。那成本包括在程序逻辑地址空间中分配内存所需的时间以及将该地址空间分配给物理内存所需的时间。如果您不打算立即使用特定的内存块，那么最好的做法是推迟分配，直到您真正需要它的时候。例如，为了避免应用程序启动缓慢，请尽量减少启动时分配的内存量。相反，请将初始内存分配重点放在显示用户界面和响应用户输入所需的对象上。推迟其他分配，直到用户问题开始与您的应用程序交互并发出命令。这种内存的惰性分配可以立即节省时间，并确保所分配的任何内存都得到实际使用。

延迟初始化可能有些棘手的地方是全局变量。由于它们对于您的应用程序来说是全局的，因此您需要确保全局变量在被其余代码使用之前已正确初始化。全局变量经常采用的基本方法是在代码模块之一中定义静态变量，并使用公共访问器函数来获取和设置该值，如清单 1 所示。



**清单 1** 通过访问器延迟分配内存

```
MyGlobalInfo* GetGlobalBuffer()
{
    静态 MyGlobalInfo* sGlobalBuffer = NULL;
    如果（sGlobalBuffer == NULL）
        {
            sGlobalBuffer = malloc( sizeof( MyGlobalInfo ) );
        }
        返回sGlobalBuffer；
}
```

唯一需要小心此类代码的情况是当它可能从多个线程调用时。在多线程环境中，您需要使用锁来保护`if`访问器方法中的语句。但这种方法的缺点是获取锁需要花费大量时间，并且每次访问全局变量时都必须完成，这对性能造成了不同程度的影响。一种更简单的方法是在应用程序的主线程生成任何其他线程之前初始化所有全局变量。



### 高效初始化内存块

使用该函数分配的小内存块`malloc`不保证用零初始化。尽管您可以使用该函数来初始化内存，但更好的选择是首先`memset`使用例程来分配内存。`calloc`这`calloc`函数为内存保留所需的虚拟地址空间，但等到内存被实际使用后再对其进行初始化。这种方法比使用更有效`memset`，这迫使虚拟内存系统将相应的页面映射到物理内存中，以便对它们进行零初始化。使用该`calloc`函数的另一个优点是，它允许系统在使用页面时初始化页面，而不是一次性初始化所有页面。



### 重用临时内存缓冲区

如果您有一个频繁使用的函数，该函数为某些计算创建一个大型临时缓冲区，您可能需要考虑重用该缓冲区，而不是在每次调用该函数时重新分配它。即使您的函数需要可变缓冲区空间，您也始终可以使用该`realloc`函数根据需要增加缓冲区。对于多线程应用程序，重用缓冲区的最佳方法是将它们添加到线程本地存储中。尽管您可以在函数中使用静态变量来存储缓冲区，但这样做会阻止您同时在多个线程上使用该函数。

缓存缓冲区消除了定期分配和释放大内存块的函数的大部分开销。然而，这种技术仅适用于频繁调用的函数。另外，您应该注意不要缓存太多大缓冲区。缓存缓冲区确实会增加应用程序的内存占用量，并且只有在测试表明它会产生更好的性能时才应使用。



### 释放未使用的内存

对于使用 malloc 库分配的内存，在使用完内存后立即释放内存非常重要。忘记释放内存可能会导致内存泄漏，从而减少应用程序可用的内存量并影响性能。如果不加以控制，内存泄漏还会使您的应用程序陷入无法执行任何操作的状态，因为它无法分配所需的内存。



**注意：** 使用自动引用计数 (ARC) 编译器选项构建的应用程序不需要显式释放 Objective-C 对象。相反，应用程序必须存储对其想要保留的对象的强引用，并删除对其不需要的对象的引用。当一个对象没有任何强引用时，编译器会自动释放它。有关支持 ARC 的更多信息，请参阅*[过渡到 ARC 发行说明](https://developer.apple.com/library/archive/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226)*。



无论您针对哪个平台，都应该始终消除应用程序中的内存泄漏。对于使用 malloc 的代码，请记住，分配内存时懒惰是可以的，但释放内存时不要懒惰。为了帮助追踪应用程序中的内存泄漏，请使用 Instruments 应用程序。



## 内存分配技术

由于内存是一种基本资源，因此 OS X 和 iOS 都提供了多种分配内存的方法。使用哪种分配技术主要取决于您的需求，但最终所有内存分配最终都会使用 malloc 库来创建内存。甚至 Cocoa 对象最终也是使用 malloc 库分配的。使用这个单一库使性能工具可以报告应用程序中的所有内存分配。

`alloc`如果您正在编写 Cocoa 应用程序，您可能只能使用方法以对象的形式分配内存`NSObject`。即便如此，有时您可能需要超越与对象相关的基本内存块并使用其他内存分配技术。例如，您可以直接使用分配内存`malloc`，以便将其传递给低级函数调用。

以下部分提供有关 malloc 库和虚拟内存系统以及它们如何执行分配的信息。这些部分的目的是帮助您确定与每种类型的专门分配相关的成本。您应该使用此信息来优化代码中的内存分配。



**注意：** 这些部分假设您正在使用系统提供的 malloc 库版本来进行分配。如果您使用自定义 malloc 库，这些技术可能不适用。





### 分配对象

对于基于 Objective-C 的应用程序，您可以使用两种技术之一来分配对象。您可以使用`alloc`类方法，然后调用类初始化方法，也可以使用类`new`方法分配对象并`init`一步调用其默认方法。

创建对象后，编译器的 ARC 功能决定对象的生命周期以及何时应删除该对象。每个新对象都需要至少一个对其的强引用，以防止它立即被释放。因此，当您创建一个新对象时，您应该始终创建至少一个对其的强引用。之后，您可以根据代码的需要创建其他强引用或弱引用。当删除对对象的所有强引用时，编译器会自动释放它。

有关 ARC 以及如何管理对象生命周期的更多信息，请参阅*[过渡到 ARC 发行说明](https://developer.apple.com/library/archive/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226)*。



### 使用 Malloc 分配小内存块

对于小型内存分配，其中“小”指的是小于几个虚拟内存页的任何内容，`malloc`从大小不断增加的空闲块列表（或“池”）中子分配所请求的内存量。您使用例程释放的任何小块`free`都会添加回池中，并在“最适合”的基础上重新使用。内存池本身由多个虚拟内存页组成，这些虚拟内存页是使用`vm_allocate`例程分配并由系统管理的。

分配任何小内存块时，请记住块的粒度malloc库分配的空间是16字节。因此，您可以分配的最小内存块是 16 字节，任何大于该内存块的内存块都是 16 的倍数。例如，如果您调用并请求`malloc`4 字节，它将返回一个大小为 16 字节的块；如果请求 24 字节，它将返回一个大小为 32 字节的块。由于这种粒度，您应该仔细设计数据结构，并尽可能使其成为 16 字节的倍数。



**注意：** 从本质上来说，小于单个虚拟内存页面的分配不能进行页面对齐。





### 使用 Malloc 分配大内存块

对于大内存分配，其中“大”不仅仅是几个虚拟内存页，`malloc`会自动使用`vm_allocate`例程来获取所请求的内存。该`vm_allocate`例程将地址范围分配给当前进程的逻辑地址空间中的新块，但它不会立即将任何物理内存分配给这些页面。相反，内核执行以下操作：

1. *它通过创建映射条目*来映射本进程虚拟地址空间中的一段内存；映射条目是一个简单的结构，定义了区域的起始和结束地址。
2. 内存范围由默认分页器支持。
3. 内核创建并初始化一个 VM 对象，将其与映射条目关联起来。

此时，物理内存中没有驻留页面，后备存储中也没有页面。一切都在系统内虚拟映射。当您的代码通过读取或写入其中的特定地址来访问部分内存块时，会发生错误，因为该地址尚未映射到物理内存。在 OS X 中，内核还认识到 VM 对象没有该地址所在页面的后备存储。然后内核对每个页面错误执行以下步骤：

1. 它从空闲列表中获取一个页面并用零填充它。
2. 它将对此页面的引用插入VM对象的驻留页面列表中。
3. 它通过填充称为*pmap*的数据结构将虚拟页映射到物理页。pmap 包含处理器（或单独的内存管理单元）使用的页表，用于将给定的虚拟地址映射到实际的硬件地址。

粒度大内存块的大小等于虚拟内存页的大小，即 4096 字节。换句话说，任何不是 4096 倍数的大内存分配都会自动舍入到该倍数。因此，如果您要分配较大的内存缓冲区，则应将缓冲区设置为此大小的倍数，以避免浪费内存。



**注意：** 大内存分配保证是页对齐的。



`vm_allocate`对于大型分配，您可能还会发现直接使用 分配虚拟内存比使用更有意义`malloc`。清单 2中的示例显示了如何使用该`vm_allocate`函数。



**清单 2** 使用 vm_allocate 分配内存

```
void* 分配虚拟内存（size_t 大小）
{
    字符*数据；
    kern_return_t 错误；
 
    // 在调试版本中，检查我们是否有
    // 正确的VM页面对齐
    检查（大小！= 0）；
    检查（（大小％4096）== 0）；
 
    // 直接从VM分配
    错误 = vm_allocate( (vm_map_t) mach_task_self(),
                        （vm_address_t*）&数据，
                        尺寸，
                        VM_FLAGS_ANYWHERE);
 
    // 检查错误
    检查（错误== KERN_SUCCESS）；
    如果（错误！= KERN_SUCCESS）
    {
        数据=空；
    }
 
    返回数据；
}

```



### 批量分配内存

如果您的代码分配多个相同大小的内存块，您可以使用`malloc_zone_batch_malloc`函数一次分配这些块。`malloc`与分配相同内存的一系列调用相比，此函数提供更好的性能。当单个块大小相对较小（小于 4K）时，性能最佳。该函数会尽力分配所有请求的内存，但返回的内存可能少于请求的内存。使用此函数时，请仔细检查返回值以了解实际分配了多少块。

OS X 版本 10.3 及更高版本以及 iOS 支持内存块的批量分配。有关信息，请参阅`/usr/include/malloc/malloc.h`头文件。



### 分配共享内存

共享内存是可以由两个或多个进程写入或读取的内存。共享内存可以继承来自父进程，由共享内存服务器创建，或者由应用程序显式创建以导出到其他应用程序。共享内存的用途包括：

- 共享大量资源，例如图标或声音
- 一个或多个进程之间的快速通信

共享内存很脆弱，当有其他更可靠的替代方案可用时，通常不推荐使用。如果一个程序损坏了共享内存的一部分，则所有也使用该内存的程序都会共享损坏的数据。用于创建和管理共享内存区域的函数位于`/usr/include/sys/shm.h`头文件中。



### 使用 Malloc 内存区域

全部内存块被分配在一个malloc区（也称为 malloc 堆）。A*区*是虚拟内存的可变大小范围，内存系统可以从中分配块。区域有自己的空闲列表和内存页面池，区域内分配的内存保留在该组页面上。当您需要创建具有相似访问模式或生命周期的内存块时，区域非常有用。您可以在一个区域中分配许多对象或内存块，然后销毁该区域以释放它们，而不是单独释放每个块。理论上，以这种方式使用区域可以最大限度地减少浪费的空间并减少寻呼活动。实际上，区域的开销通常会消除与区域相关的性能优势。



**注意：** 术语区域与术语堆同义， 水池和 arena 在使用`malloc`例程的内存分配方面。



默认情况下，使用该`malloc`函数进行的分配发生在默认 malloc 区域内，该区域是在`malloc`应用程序首次调用时创建的。尽管通常不建议这样做，但如果测量显示代码中存在潜在的性能提升，您可以创建其他区域。例如，如果释放大量临时（和隔离）对象会减慢应用程序的速度，您可以将它们分配在一个区域中，然后简单地取消分配该区域。

如果您在自定义 malloc 区域中创建对象（或分配内存块），则可以在完成后释放整个区域，而不是单独释放区域分配的对象或内存块。执行此操作时，请确保您的应用程序数据结构不保存对自定义区域中内存的引用。尝试访问已释放区域中的内存将导致内存故障并使应用程序崩溃。



**警告：** 您永远不应该取消分配应用程序的默认区域。



在 malloc 库级别，对区域的支持在`/usr/include/malloc/malloc.h`. 使用该`malloc_create_zone`函数创建自定义 malloc 区域或使用该`malloc_default_zone`函数获取应用程序的默认区域。要在特定区域分配内存，请使用`malloc_zone_malloc`、`malloc_zone_calloc`、`malloc_zone_valloc`或`malloc_zone_realloc`函数。要释放自定义区域中的内存，请调用`malloc_destroy_zone`.



## 使用 Malloc 复制内存

在 OS X 中复制内存有两种主要方法：直接复制和延迟复制。对于大多数情况，直接方法可提供最佳的整体性能。然而，有时使用延迟复制操作有其好处。以下部分的目标是向您介绍复制内存的不同方法以及可能使用这些方法的情况。



### 直接复制内存

内存的直接复制涉及使用诸如`memcpy`或者`memmove`将字节从一个块复制到另一个块。复制时源块和目标块都必须驻留在内存中。然而，这些例程特别适合以下情况：

- 您要复制的块的大小很小（小于 16 KB）。
- 您打算立即使用源或目标。
- 源块或目标块未页对齐。
- 源块和目标块重叠。

如果您在一段时间内不打算使用源数据或目标数据，则执行直接复制可能会显着降低大内存块的性能。直接复制内存会增加应用程序工作集的大小。每当您增加应用程序的工作集时，就会增加分页到磁盘的机会。如果工作集中有一个大内存块的两个直接副本，您最终可能会将它们都分页到磁盘。当您稍后访问源或目标时，您需要从磁盘加载数据，这比执行`vm_copy`延迟复制操作要昂贵得多。



**注意：** 如果源块和目标块重叠，您应该更喜欢使用`memmove`over `memcpy`。的实现`memmove`在 OS X 中正确处理重叠块，但不保证 的实现`memcpy`能够这样做。





### 延迟内存复制操作

如果您打算复制许多页面的内存，但不打算立即使用源页面或目标页面，那么您可能需要使用`vm_copy`函数来执行此操作。`memmove`与or不同`memcpy`，`vm_copy`不触及任何真实内存。它修改虚拟内存映射以指示目标地址范围是源地址范围的写时复制版本。

例行公事比在非常具体的情况下`vm_copy`更有效。`memcpy`具体来说，如果您的代码在复制操作后相当长的一段时间内不访问源内存或目标内存，则它会更有效。对延迟使用有效的原因`vm_copy`是内核处理写时复制情况的方式。为了执行复制操作，内核必须从虚拟内存系统中删除对源页面的所有引用。下次进程访问该源页面上的数据时，会发生软故障，内核会将该页面作为写时复制页面映射回进程空间。处理单个软故障的过程几乎与直接复制数据一样昂贵。



### 复制少量数据

如果您需要复制一小块不重叠的数据，您应该优先选择`memcpy`任何其他例程。对于小内存块，GCC 编译器可以优化此例程，将其替换为内联指令以按值复制数据。编译器可能不会优化其他例程，例如`memmove`或`BlockMoveData`。



### 将数据复制到视频 RAM

将数据复制到 VRAM 时， 使用`BlockMoveDataUncached`函数而不是诸如`bcopy`. 这`bcopy`函数使用可能导致异常错误的缓存操作指令。内核必须修复这些错误才能继续，这会极大地降低性能。



## 响应 iOS 中的低内存警告

iOS 中的虚拟内存系统不使用后备存储，而是依赖应用程序的协作来删除对对象的强引用。当空闲页面数量低于计算的阈值时，系统会尽可能释放未修改的页面，但也可能向当前正在运行的应用程序发送内存不足通知。如果您的应用程序收到此通知，请注意警告。收到它后，您的应用程序必须删除对尽可能多的对象的强引用。例如，您可以使用警告清除数据缓存，以便稍后重新创建。

UIKit 提供了多种接收低内存通知的方法，包括以下几种：

- 实现`applicationDidReceiveMemoryWarning:`应用程序委托的方法。
- 重写`didReceiveMemoryWarning`自定义子类中的方法`UIViewController`。
- 注册以接收`UIApplicationDidReceiveMemoryWarningNotification`通知。

收到任何这些通知后，您的处理程序方法应该通过立即删除对对象的强引用来做出响应。视图控制器会自动删除对当前屏幕外视图的引用，但您还应该重写该`didReceiveMemoryWarning`方法并使用它来删除视图控制器不需要的任何其他引用。

如果您只有少数具有已知可清除资源的自定义对象，则可以让这些对象注册通知`UIApplicationDidReceiveMemoryWarningNotification`并删除其中的引用。但是，如果您有许多可清除的对象或只想有选择地仅清除某些对象，您可能需要使用应用程序委托来决定保留哪些对象。



**重要提示：** 与系统应用程序一样，您的应用程序应始终处理低内存警告，即使它们在测试期间没有收到这些警告。系统应用程序在处理请求时消耗少量内存。当检测到内存不足的情况时，系统会向所有正在运行的程序（包括您的应用程序）发出内存不足警告，并可能终止某些后台应用程序（如有必要）以缓解内存压力。如果没有释放足够的内存（可能是因为您的应用程序正在泄漏或仍然消耗太多内存），系统仍可能终止您的应用程序。



[下一个](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/CachingandPurgeableMemory.html)[以前的](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html)



# 缓存和可清除内存

对于正在处理需要大量内存或计算时间的大型对象的开发人员，或者当计算机因 RAM 已满而将数据写入磁盘时代码陷入困境的开发人员来说，缓存和可清除内存可能是至关重要的资产。



## 缓存概述

缓存是可以极大提高应用程序性能的对象或数据的集合。



### 为什么要使用缓存？

开发人员使用缓存来存储经常访问的对象以及计算成本较高的瞬态数据。重用这些对象可以提供性能优势，因为不必重新计算它们的值。但是，这些对象对于应用程序并不重要，如果内存紧张，可以将其丢弃。如果被丢弃，则在需要时必须重新计算它们的值。



### 缓存可能导致的问题

尽管缓存可以在性能方面带来巨大的好处，但缓存也可能带来一些缺点。最重要的是，缓存可能会使用大量内存。当缓存许多大数据对象时，可能会缓存太多对象，以至于没有 RAM 可供其他应用程序使用，并且计算机将在将所有这些数据写入磁盘以释放 RAM 时陷入停顿。



### 解决方案

Cocoa 提供了一个`NSCache`对象作为您想要缓存的项目的方便存储容器，同时解决了上面讨论的内存管理问题。该类`NSCache`与该类非常相似`NSDictionary`，因为它们都保存键值对。然而，`NSCache`对象是一个“反应式缓存”。也就是说，当内存可用时，它会积极缓存给定的任何数据。然而，当内存不足时，它会自动丢弃一些元素，以便为其他应用程序释放内存。以后，如果需要这些废弃的物品，则必须重新计算它们的价值。

`NSCache`提供了另外两个有用的“限制”功能：限制缓存元素的数量和限制缓存中所有元素的总成本。要限制缓存允许拥有的元素数量，请调用 方法`setCountLimit:`。例如，如果您尝试将 11 个项目添加到`countLimit`设置为 的缓存中`10`，缓存可能会自动丢弃其中一个元素。

将项目添加到缓存时，您可以指定`cost`与每个键值对关联的值。调用该`setTotalCostLimit:`方法设置所有缓存对象成本总和的最大值。因此，当添加一个对象来推动`totalCost`上面的`totalCostLimit`时，缓存可以自动驱逐它的一些对象，以便回到阈值以下。此驱逐过程不受保证，因此尝试操纵`cost`值以实现特定行为可能会损害缓存的性能。`0`如果`cost`没有什么有用的就传入，或者使用`setObject:forKey:`不需要传入成本的方法。



**注意：** 计数限制和总成本限制并未严格执行。也就是说，当缓存超过其限制之一时，其某些对象可能会立即、稍后或永远不会被驱逐，这一切都取决于缓存的实现细节。





## 使用可清除内存

Cocoa 框架还提供了该类`NSPurgeableData`来帮助确保您的应用程序不会占用太多内存。该类`NSPurgeableData`采用该`NSDiscardableContent`协议，任何类都可以实现该协议，以允许在该类实例的客户端完成访问这些对象时丢弃内存。`NSDiscardableContent`您应该在创建具有一次性子组件的对象时实现。此外，该类`NSPurgeableData`不必与 ; 一起使用`NSCache`。您可以独立使用它来获得清除行为。



### 使用可清除内存的优点

通过使用可清除内存，您可以让系统在需要时快速恢复内存，从而提高性能。标记为可清除的内存在被虚拟内存系统回收时不会被分页到磁盘，因为分页是一个耗时的过程。相反，数据会被丢弃，如果以后需要，则必须重新计算。

使用可清除内存时需要注意的是，在访问内存块之前必须先锁定该内存块。此锁定机制对于确保在您访问数据时不会有自动删除策略尝试处置数据是必要的。同样，锁定机制将确保虚拟内存系统尚未丢弃数据。该类`NSPurgeableData`实现了一个非常简单的锁定机制，以确保数据在读取时是安全的。



### 如何实现可清除内存

该类`NSPurgeableData`使用起来非常简单，因为该类只是实现了`NSDiscardableContent`协议。“计数器”变量的概念是`NSDiscardableContent`对象生命周期的核心。当该对象使用的内存正在被读取或仍然需要时，其计数器变量将大于或等于`1`。当它不被使用并且可以被丢弃时，计数器变量等于`0`。

当计数器等于 时`0`，如果内存紧张，则可能会丢弃该内存块。要丢弃内容，请调用`discardContentIfPossible`该对象，如果计数器变量等于 ，则该对象将释放关联的内存`0`。

默认情况下，当一个`NSPurgeableData`对象被初始化时，它被创建时计数器变量等于`1`并且可以安全地访问。要访问可清除内存，只需调用该`beginContentAccess`方法即可。此方法将首先检查以确保对象的数据没有被丢弃。如果数据仍然存在，它将递增计数器变量以在读取数据时保护内存，并返回`YES`。如果数据已被丢弃，该方法将返回`NO`。当您完成数据访问后，调用`endContentAccess`，这会减少计数器并允许在系统需要时丢弃内存。您必须跟踪计数器变量的状态，并且仅当`beginContentAccess`方法返回时才访问内存`YES`。

```
discardContentIfPossible`如果系统可用内存不足，系统或客户端对象将调用该方法来丢弃可清除的数据。仅当其计数器变量为 时，此方法才会丢弃数据`0`，否则不执行任何操作。最后，如果内存已被丢弃，该`isContentDiscarded`方法将返回。`YES
```

下面是一个对象生命周期的示例`NSPurgeableData`：

```
NSPurgeableData * data = [[NSPurgeableData alloc] init];
[data endContentAccess]; //Don't necessarily need data right now, so mark as discardable.
//Maybe put data into a cache if you anticipate you will need it later.
 
...
 
if([data beginContentAccess]) { //YES if data has not been discarded and counter variable has been incremented
     ...Some operation on the data...
     [data endContentAccess] //done with the data, so mark as discardable
} else {
     //data has been discarded, so recreate data and complete operation
     data = ...
     [data endContentAccess]; //done with data
}
 
//data is able to be discarded at this point if memory is tight

```



### 可清除内存和 NSCache

当实现该`NSDiscardableContent`协议的对象放入`NSCache`对象中时，缓存会保留对该对象的强引用。但是，如果对象的内容已被丢弃并且缓存的`evictsObjectsWithDiscardedContent`值设置为`YES`，则该对象会自动从缓存中删除，并且不会被查找调用找到。



### 关于可清除内存的一些警告

使用可清除内存的一个警告是，只有大对象或内存块可以直接使用它。可清除内存 API 作用于多页虚拟内存对象，这使得很难将单个小缓存元素标记为可清除。缓存 API 将执行所需的簿记操作，以允许小型缓存元素使用可清除内存。同样，在某些情况下，直接通过 API 为缓存元素分配内存会很尴尬，例如当使用便捷方法来分配对象时，或者当对象分配在与进行缓存的层不同的层中时。在这种情况下，不可能使用可清除内存。



## 何时使用可清除内存

当预期的清除成本小于预期的分页成本时（当分页成本大于重新计算特定数据值的成本乘以该数据项被重用的概率时），使用可清除内存是有意义的。许多缓存都属于这一类，因为它们的推测性质使得这些物品很可能不会被再次使用。同样，易于重新计算的缓存项是可清除内存的主要候选者，因为如果必须重新计算它们的值，应用程序不会遭受巨大的性能损失。



# 跟踪内存使用情况

如果您怀疑您的代码没有尽可能有效地使用内存，那么确定是否存在问题的第一步是收集一些基线数据。使用 Apple 提供的性能工具之一监视代码可以让您了解代码的内存使用情况，并可能突出显示潜在问题或指出需要进一步检查的区域。以下部分介绍了最常用于内存分析的工具以及何时需要使用它们。



## 使用工具跟踪分配

Instruments 应用程序始终是进行任何类型性能分析的良好起点。仪器是一个集成的数据收集环境，它使用特殊模块（称为仪器）来收集有关过程的各种信息。仪器可以对应用程序的传送二进制文件进行操作 - 您无需将特殊模块编译到应用程序中即可使用它。Instruments 应用程序的库包含四个模块，专门用于收集内存相关数据。这些模块如下：

- ObjectAlloc 工具记录并显示自应用程序启动以来所有内存分配的历史记录。
- Leaks 工具会查找程序代码不再引用的已分配内存；请参阅[使用仪器查找泄漏](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingLeaks.html#//apple_ref/doc/uid/20001883-SW2)。
- 共享内存工具监视共享内存区域的打开和取消链接。
- 内存监视器工具测量并记录系统的总体内存使用情况。

您可以将任何或所有这些仪器添加到单个跟踪文档中，并同时收集每个仪器的数据。能够一次性收集所有数据，让您能够将一台仪器的信息与其他仪器的信息关联起来。例如，Leaks 工具通常与 ObjectAlloc 工具结合使用，这样您就可以跟踪分配情况并找出哪些分配被泄漏。

为您的应用程序收集数据后，您需要对其进行分析。以下部分提供了有关如何使用几种与内存相关的仪器分析数据的提示。有关如何使用泄漏仪器的信息，请参阅[使用仪器查找泄漏](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingLeaks.html#//apple_ref/doc/uid/20001883-SW2)。



### 使用 ObjectAlloc Instrument 分析内存分配

您可以使用 ObjectAlloc 工具来跟踪应用程序的内存分配活动。该仪器跟踪从应用程序启动到您停止记录数据的内存分配。该工具根据创建的对象数量和创建的对象的大小（或类型）向您显示分配情况。在图标查看模式下，仪器显示实时直方图，让您可以直接看到发生的变化和趋势。它还保留分配和释放的历史记录，使您有机会返回并查看这些对象的分配位置。

ObjectAlloc 工具显示的信息由内置于 Core Foundation 框架中的分配统计工具记录。当此功能处于活动状态时，每次分配和释放都会在发生时记录下来。



### 分析共享内存使用情况

对于 Mac 应用程序，共享内存工具会跟踪对任何`shm_open`和`shm_unlink`函数的调用，这些函数用于打开和关闭系统中的共享内存区域。您可以使用此信息来找出应用程序从何处获取对共享内存区域的引用，并检查进行这些调用的频率。详细信息窗格显示每个函数调用的列表以及有关调用时的调用环境的信息。具体来说，该窗格列出了发起调用的可执行文件和函数参数。打开扩展详细信息窗格会显示与调用关联的堆栈跟踪。



### 分析内存监控仪器的数据

对于 Mac 应用程序，内存监视器工具显示有关系统内存使用情况的各种统计数据。您可以使用此工具查看应用程序或整个系统中的内存使用趋势。例如，您可以查看当前有多少内存处于活动状态、非活动状态、已连接状态和空闲状态。您还可以查看已调入或调出的内存量。您可以将此工具与其他工具结合使用来跟踪应用程序在特定操作方面使用的内存量。



## 使用 malloc_history 跟踪内存分配

在 OS X 中，该`malloc_history`工具显示回溯数据，准确显示程序调用`malloc`和`free`函数的位置。如果您在调用时指定地址`malloc_history`，则该工具仅跟踪该地址处发生的内存分配。如果指定`-all_by_size`或`-all_by_count`选项，该工具将显示所有分配，并将频繁分配分组在一起。

在您的程序上使用该`malloc_history`工具之前，您必须首先通过设置启用 malloc 库日志记录功能`MallocStackLogging`到`1`. 您可能还想设置`MallocStackLoggingNoCompact`环境变量来保留有关已释放块的信息。有关这些变量的更多信息，请参阅[启用 Malloc 调试功能](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html#//apple_ref/doc/uid/20001884-CJBJFIDD)。

该`malloc_history`工具最适合在需要查找内存块的前任所有者的情况下使用。如果您确定特定数据在某种程度上被损坏，您可以在代码中进行检查，以在发生损坏时打印该块的地址。然后，您可以用来`malloc_history`找出谁拥有该块并识别任何过时的指针。

该`malloc_history`工具还适用于无法使用 Sampler 的情况。例如，您可以从远程计算机或在您希望对程序行为影响最小的情况下使用此工具。

有关使用该`malloc_history`工具的更多信息，请参阅`malloc_history`手册页。



## 使用堆工具检查内存

在 OS X 中，`heap`命令行工具显示由 malloc 库分配并位于指定进程的地址空间中的内存的快照。对于 Cocoa 应用程序，该工具通过名称识别 Objective-C 对象。对于内存块和对象，该工具按堆组织信息，将同一堆中的所有项目显示在一起。

该`heap`工具提供了与 ObjectAlloc 工具大部分相同的信息，但其侵入性要小得多。您可以从远程会话或在使用仪器可能会减慢系统速度并影响结果输出的情况下使用此工具。

有关使用该`heap`工具的更多信息，请参阅`heap(1)`手册页。



# 查找内存泄漏

内存泄漏是程序不再引用的已分配内存块。通过用不可访问的数据填充内存页来泄漏浪费空间，并由于额外的分页活动而浪费时间。泄漏的内存最终会迫使系统为应用程序分配额外的虚拟内存页，而通过回收泄漏的内存可以避免分配这些虚拟内存页。

对于使用 malloc 的应用程序，内存泄漏是错误，应该始终修复。对于仅使用 Objective-C 对象的应用程序，编译器的 ARC 功能会为您释放对象，通常可以避免内存泄漏问题。然而，混合使用 Objective-C 对象和基于 C 的结构的应用程序必须更直接地管理对象的所有权，以确保对象不被泄漏。

malloc 库只能回收您告诉它回收的内存。如果您调用`malloc`或任何分配内存的例程，则必须平衡该调用与相应的`free`. 当您忘记为嵌入数据结构中的指针释放内存时，就会发生典型的内存泄漏。如果您为代码中的嵌入指针分配内存，请确保在释放数据结构本身之前释放该指针的内存。

当您分配内存，将其分配给指针，然后向该指针分配不同的值而不释放第一个内存块时，会发生另一个典型的内存泄漏示例。在此示例中，覆盖指针中的地址会擦除对原始内存块的引用，从而使其无法释放。



## 使用仪器查找泄漏

Instruments 应用程序可用于查找 OS X 和 iPhone 应用程序中的泄漏。要查找泄漏，请在 Instruments 中创建一个新文档模板并向其中添加 Leaks 工具。`leaks`Leaks 仪器提供与命令行工具相同的泄漏检测功能。Leaks 工具记录应用程序中发生的所有分配事件，然后定期搜索应用程序的可写内存、寄存器和堆栈以查找对任何活动内存块的引用。如果它在这些位置之一没有找到对块的引用，它会认为该块是“泄漏”并在详细信息窗格中显示相关信息。

在详细信息窗格中，您可以使用表格和大纲模式查看泄漏的内存块。在表格模式下，仪器显示泄漏块的完整列表，按大小排序。选择表中的一个条目并单击内存地址旁边的箭头按钮将显示该地址处内存块的分配历史记录。从此分配历史记录中选择一个条目，然后在文档窗口的扩展详细信息窗格中显示该事件的堆栈跟踪。在大纲模式下，泄漏工具显示按调用树组织的泄漏，您可以使用它来获取有关代码特定分支中泄漏的信息。

有关使用仪器应用程序的更多信息，包括有关 Leaks 仪器显示的信息的更多信息，请参阅*[仪器用户指南](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652)*。



## 使用泄漏工具

在 OS X 中，`leaks`命令行工具在进程的虚拟内存空间中搜索已分配`malloc`但不再引用的缓冲区。对于它找到的每个泄漏缓冲区，`leaks`显示以下信息：

- 泄漏内存的地址
- 泄漏的大小（以字节为单位）
- 泄漏缓冲区的内容

如果`leaks`可以确定该对象是 Objective-C 或 Core Foundation 对象的实例，它还会显示该对象的名称。如果不想查看每个泄漏缓冲区的内容，可以`-nocontext`在调用时指定该选项`leaks`。如果`MallocStackLogging`设置了环境变量并且您正在运行应用程序`gdb`，`leaks`则会显示描述缓冲区分配位置的堆栈跟踪。有关`malloc`调试选项的更多信息，请参阅[启用 Malloc 调试功能](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html#//apple_ref/doc/uid/20001884-CJBJFIDD)。



**注意：** leaks 命令行工具位于`/usr/bin`.





## 改进泄漏检测的技巧

以下指南可以帮助您快速发现程序中的内存泄漏。这些指南中的大多数旨在与该`leaks`工具一起使用，但有些指南也适用于一般用途。

- `leaks`在单元测试期间运行。由于单元测试以可重复的方式测试所有代码路径，因此与在生产环境中测试代码相比，您更有可能发现泄漏。
- 使用`-exclude`选项`leaks`过滤掉已知内存泄漏的函数中的泄漏。此选项有助于减少 报告的无关信息量`leaks`。
- 如果`leaks`间歇性地报告泄漏，请在目标代码路径周围设置一个循环，并运行代码数百或数千次。这增加了泄漏更频繁地重新出现的可能性。
- `libgmalloc.dylib`在 中运行您的程序`gdb`。该库是一个积极的调试 malloc 库，可以帮助跟踪代码中的潜在错误。有关更多信息，请参见`libgmalloc`手册页。
- 对于 Cocoa 和 iPhone 应用程序，如果您修复了泄漏并且您的程序开始崩溃，则您的代码可能正在尝试使用已经释放的对象或内存缓冲区。`NSZombieEnabled`将环境变量设置为`YES`来查找已释放对象的消息。

大多数单元测试代码都会执行所需的代码路径并退出。尽管这对于单元测试来说是完全正常的，但它给工具带来了问题`leaks`，需要时间来分析进程内存空间。要解决此问题，您应该确保单元测试代码在完成测试后不会立即退出。您可以通过使进程无限期地休眠而不是正常退出来实现此目的。



# 启用 Malloc 调试功能

如果您不知道从哪里开始查找，那么调试与内存相关的错误可能会非常耗时。这通常会因以下问题而变得更加复杂：许多内存错误是在代码操作相关内存之后很久才发生的。幸运的是，Xcode 包含一些选项，可以在更接近实际发生内存问题时识别这些问题。



## 启用 Guard Malloc

Guard Malloc 是 malloc 库的特殊版本，在调试期间替代标准库。Guard Malloc 使用多种技术尝试在发生内存错误的特定点使应用程序崩溃。例如，它将单独的内存分配放置在不同的虚拟内存页面上，然后在释放内存时删除整个页面。随后尝试访问已解除分配的内存会立即导致内存异常，而不是盲目访问现在可能保存其他数据的内存。当发生崩溃时，您可以去调试器中检查故障点以找出问题所在。

[要使用 Guard Malloc 启用调试，请在Xcode 方案编辑器](http://help.apple.com/xcode)中将项目配置为使用 Guard Malloc 运行

。您可以对在模拟器中运行的 Mac 应用程序和 iOS 应用程序使用此选项。

有关 Guard Malloc 可以帮助您追踪的内存问题类型的更多信息，请参阅*OS X 手册页*`libgmalloc`中的手册页。



## 配置 Malloc 环境变量

malloc库提供调试功能，帮助您跟踪内存崩溃错误、堆损坏、对已释放内存的引用以及缓冲区溢出。您可以通过一组环境变量启用这些调试选项。除了`MallocCheckHeapStart`和之外`MallocCheckHeapEach`，大多数环境变量的值都会被忽略。要从终端禁用变量，请使用`unset` 命令。表 1列出了一些关键环境变量并描述了它们的基本功能。有关变量的完整列表，请参阅`malloc`手册页。



| 多变的                        | 描述                                                         |
| :---------------------------- | :----------------------------------------------------------- |
| `MallocStackLogging`          | 如果设置，`malloc`则记住每次分配时的函数调用堆栈。           |
| `MallocStackLoggingNoCompact` | 此选项类似于，`MallocStackLogging`但确保记录所有分配，无论缓冲区有多小或多短。 |
| `MallocScribble`              | 如果设置，`free`则将每个已释放块的每个字节设置为值`0x55`。   |
| `MallocPreScribble`           | 如果设置，`malloc`则将新分配的块的每个字节设置为值`0xAA`。这增加了程序对新分配的内存进行假设失败的可能性。 |
| `MallocGuardEdges`            | 如果设置，`malloc`则在大型分配之前和之后添加保护页。         |
| `MallocDoNotProtectPrelude`   | 对行为的细粒度控制`MallocGuardEdges`：如果设置，`malloc`则不会在每个大块分配的头部放置保护页。 |
| `MallocDoNotProtectPostlude`  | 对行为的细粒度控制`MallocGuardEdges`：如果设置，`malloc`则不会在每个大块分配的尾部放置保护页。 |
| `MallocCheckHeapStart`        | `malloc`将此变量设置为开始验证堆之前的分配数量。如果未设置，`malloc`则不验证堆。 |
| `MallocCheckHeapEach`         | `malloc`将此变量设置为验证堆之前的分配数量。如果未设置，`malloc`则不验证堆。 |

以下示例在运行应用程序之前在当前 shell 中启用堆栈日志记录和堆检查。的值`MallocCheckHeapStart`设置为 1，但无关紧要，可以设置为您想要的任何值。您还可以从 shell 的启动文件中设置这些变量，但如果您确实设置了`export`每个变量。

```
% MallocStackLogging=1
% MallocCheckHeapStart=1000
% MallocCheckHeapEach=100
% ./my_tool
```

如果要在 中运行程序`gdb`，可以使用命令从 Xcode 调试控制台设置环境变量`set env`，如以下示例所示：

```
% gdb
(gdb) set env MallocStackLogging 1
(gdb) run
```

某些性能工具需要设置这些选项才能收集数据。例如，如果设置了`malloc_history`该标志，该工具可以识别特定块的分配站点。如果设置了环境变量，`MallocStackLogging`该工具还可以描述先前在某个地址分配的块。如果设置的话，命令行`MallocStackLoggingNoCompact`工具`leaks`将命名泄漏缓冲区的分配站点。有关详细信息，`MallocStackLogging`请参阅手册页`leaks`和。`malloc_history`



### 检测双释放内存

malloc 库报告尝试调用`free`已释放的缓冲区。如果您启用了该`MallocStackLoggingNoCompact`选项，则可以使用记录的堆栈信息来找出代码中第二次`free`调用的位置。然后，您可以使用此信息在调试器中设置适当的断点并跟踪问题。

malloc 库向 报告信息`stderr`。



### 检测堆损坏

`MallocCheckHeapStart`要启用堆检查，请为和环境变量赋值`MallocCheckHeapEach`。您必须设置这两个变量才能启用堆检查。该`MallocCheckHeapStart`变量告诉 malloc 库`malloc`在启动第一次堆检查之前要处理多少次调用。将第二个设置为`malloc`堆检查之间要处理的调用次数。

`MallocCheckHeapStart`当堆损坏在可预测的时间发生时，该变量非常有用。一旦到达适当的起点，malloc 库就会开始将分配消息记录到终端窗口。您可以观察分配数量并使用该信息来确定堆被损坏的大致位置。`MallocCheckHeapStart`根据需要调整和 的值`MallocCheckHeapEach`以缩小实际损坏点的范围。



### 检测内存崩溃错误

要查找内存崩溃错误，请启用该`MallocScribble`变量。该变量将无效数据写入已释放的内存块，其执行会导致发生异常。使用此变量时，还应该设置`MallocStackLogging`和`MallocStackLoggingNoCompact`变量来记录异常的位置。当异常发生时，您可以使用该`malloc_history`命令来追踪分配内存块的代码。然后，您可以使用此信息来跟踪代码并查找指向此块的任何残留指针。



# 查看虚拟内存使用情况

如果您需要有关虚拟内存使用情况的更多详细信息，您可以使用`top`、`vm_stat`、`pagestuff`和`vmmap`命令行工具来分析您的 Mac 应用程序。这些工具返回的信息范围从有关所有系统进程的摘要信息到有关特定进程的详细信息。

以下各节提供有关使用`vm_stat`、`pagestuff`和`vmmap`工具收集详细内存信息的信息。有关使用 Instruments 分析内存的更多信息，请参阅*[Instruments 用户指南](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652)*和本文档中的其他文章。有关如何使用该`top`工具的信息，请参阅*[性能概述](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410)*。



## 查看虚拟内存统计信息

这`vm_stat`该工具显示有关系统当前虚拟内存使用情况的高级统计信息。默认情况下，`vm_stat`显示这些统计信息一次，但您可以指定一个间隔值（以秒为单位）来连续更新这些统计信息。有关该工具的使用信息，请参阅`vm_stat`手册页。

清单 1显示了 的输出示例`vm_stat`。



**清单 1**  vm_stat 工具的输出

```
Mach Virtual Memory Statistics: (page size of 4096 bytes)
Pages free:                     3194.
Pages active:                  34594.
Pages inactive:                17870.
Pages wired down:               9878.
"Translation faults":        6333197.
Pages copy-on-write:           81385.
Pages zero filled:           3180051.
Pages reactivated:            343961.
Pageins:                       33043.
Pageouts:                      78496.
Object cache: 66227 hits of 96952 lookups (68% hit rate)

```



## 查看 Mach-O 代码页

这`pagestuff`工具显示有关符合 Mach-O 可执行格式的文件的指定逻辑页的信息。对于每个指定的代码页，都会显示符号（函数和静态数据结构名称）。`__TEXT, __text`如果未给出页码，则显示该部分中的所有页面。

清单 2`pagestuff`显示了TextEdit 应用程序的部分输出。此输出是使用该选项运行该工具的结果`-a`，该选项打印有关所有可执行文件的代码页的信息。它包括每个页面的虚拟地址位置以及该页面上的信息类型。



**清单 2**  pagestuff 工具的部分输出

```
File Page 0 contains Mach-O headers
File Page 1 contains Mach-O headers
File Page 2 contains contents of section (__TEXT,__text)
Symbols on file page 2 virtual address 0x3a08 to 0x4000
File Page 3 contains contents of section (__TEXT,__text)
Symbols on file page 3 virtual address 0x4000 to 0x5000
File Page 4 contains contents of section (__TEXT,__text)
Symbols on file page 4 virtual address 0x5000 to 0x6000
 
...
 
File Page 22 contains contents of section (__TEXT,__cstring)
File Page 22 contains contents of section (__TEXT,__literal4)
File Page 22 contains contents of section (__TEXT,__literal8)
File Page 22 contains contents of section (__TEXT,__const)
Symbols on file page 22 virtual address 0x17000 to 0x17ffc
File Page 23 contains contents of section (__DATA,__data)
File Page 23 contains contents of section (__DATA,__la_symbol_ptr)
File Page 23 contains contents of section (__DATA,__nl_symbol_ptr)
File Page 23 contains contents of section (__DATA,__dyld)
File Page 23 contains contents of section (__DATA,__cfstring)
File Page 23 contains contents of section (__DATA,__bss)
File Page 23 contains contents of section (__DATA,__common)
Symbols on file page 23 virtual address 0x18000 to 0x18d48
 0x00018000 _NXArgc
 0x00018004 _NXArgv
 0x00018008 _environ
 0x0001800c ___progname
...
```



在前面的清单中，如果页面导出任何符号，则该`-a`选项也会显示这些符号。如果您想查看单个页面的符号，请传入所需的页码而不是选项`-a`。有关该`pagestuff`工具及其支持的选项的更多信息，请参阅`pagestuff`手册页。



## 查看虚拟内存区域

和工具显示为指定进程分配`vmmap`的`vmmap64`虚拟内存区域。这些工具分别提供对 32 位和 64 位应用程序虚拟内存的访问。您可以使用它们来了解给定地址处内存的用途以及该内存的使用方式。对于每个虚拟内存区域，这些工具显示页面类型、起始地址、区域大小（以千字节为单位）、读/写权限、共享模式以及该区域中页面的用途。

以下部分向您展示如何解释该`vmmap`工具的输出。有关`vmmap`和`vmmap64`工具的更多信息，请参见`vmmap`或`vmmap64`手册页。



### vmmap 的输出示例

清单 3显示了该工具的一些示例输出`vmmap`。此示例不是该工具输出的完整列表，而是显示主要部分的缩写版本。



**清单 3**  vmmap 的典型输出

```
==== Non-writable regions for process 313
__PAGEZERO              0 [   4K] ---/--- SM=NUL ...ts/MacOS/Clock
__TEXT               1000 [  40K] r-x/rwx SM=COW ...ts/MacOS/Clock
__LINKEDIT           e000 [   4K] r--/rwx SM=COW ...ts/w/Clock
                    90000 [   4K] r--/r-- SM=SHM
                   340000 [3228K] r--/rwx SM=COW 00000100 00320...
                   789000 [3228K] r--/rwx SM=COW 00000100 00320...
Submap           90000000-9fffffff r--/r-- machine-wide submap
__TEXT           90000000  [ 932K] r-x/r-x SM=COW /usr/lib/libSystem.B.dylib
__LINKEDIT       900e9000   [ 260K] r--/r-- SM=COW /usr/lib/libSystem.B.dylib
__TEXT           90130000 [ 740K] r-x/r-x SM=COW .../Versions/A/CoreFoundation
__LINKEDIT       901e9000 [ 188K] r--/r-- SM=COW .../Versions/A/CoreFoundation
__TEXT           90220000 [2144K] r-x/r-x SM=COW .../Versions/A/CarbonCore
__LINKEDIT       90438000 [ 296K] r--/r-- SM=COW .../Versions/A/CarbonCore
 
[...data omitted...]
 
==== Writable regions for process 606
__DATA             18000 [   4K] rw-/rwx SM=PRV /Contents/MacOS/TextEdit
__OBJC             19000 [   8K] rw-/rwx SM=COW /Contents/MacOS/TextEdit
MALLOC_OTHER       1d000 [ 256K] rw-/rwx SM=PRV
MALLOC_USED(DefaultMallocZone_0x5d2c0)     5d000 [ 256K] rw-/rwx SM=PRV
                   9d000 [ 372K] rw-/rwx SM=COW 33320000 00000020 00000000 00001b84...
VALLOC_USED(DefaultMallocZone_0x5d2c0)     ff000 [  36K] rw-/rwx SM=PRV
MALLOC_USED(CoreGraphicsDefaultZone_0x10  108000 [ 256K] rw-/rwx SM=PRV
MALLOC_USED(CoreGraphicsRegionZone_0x148  148000 [ 256K] rw-/rwx SM=PRV
 
[...data omitted...]
 
Submap           a000b000-a012ffff r--/r-- process-only submap
__DATA           a0130000 [  28K] rw-/rw- SM=COW .../Versions/A/CoreFoundation
Submap           a0137000-a021ffff r--/r-- process-only submap
__DATA           a0220000 [  20K] rw-/rw- SM=COW .../Versions/A/CarbonCore
Submap           a0225000-a048ffff r--/r-- process-only submap
__DATA           a0490000 [  12K] rw-/rw- SM=COW .../IOKit.framework/Versions/A/IOKit
Submap           a0493000-a050ffff r--/r-- process-only submap
__DATA           a0510000 [  36K] rw-/rw- SM=COW .../Versions/A/OSServices
                 b959e000 [   4K] rw-/rw- SM=SHM
                 b95a0000 [   4K] rw-/rw- SM=SHM
                 b9630000 [ 164K] rw-/rw- SM=SHM
                 b965a000 [ 896K] rw-/rw- SM=SHM
                 bff80000 [ 504K] rw-/rwx SM=ZER
STACK[0]         bfffe000 [   4K] rw-/rwx SM=PRV
                 bffff000 [   4K] rw-/rwx SM=PRV
__DATA           c000c000 [   4K] rw-/rwx SM=PRV .../Versions/A/ApplicationEnhancer
STACK[1]         f0001000 [ 512K] rw-/rwx SM=PRV
                 ff002000 [12272K] rw-/rw- SM=SHM
 
==== Legend
SM=sharing mode:
    COW=copy_on_write PRV=private NUL=empty ALI=aliased
    SHM=shared ZER=zero_filled S/A=shared_alias
 
==== Summary for process 313
ReadOnly portion of Libraries: Total=27420KB resident=12416KB(45%) swapped_out_or_unallocated=15004KB(55%)
Writable regions: Total=21632KB written=536KB(2%) resident=1916KB(9%) swapped_out=0KB(0%) unallocated=19716KB(91%)
```

如果指定该`-d`参数（加上以秒为单位的时间间隔），`vmmap`则会拍摄虚拟内存使用情况的两个快照（一个在指定时间间隔开始时，另一个在指定时间间隔结束时）并显示差异。它显示了三组差异：

- 个体差异
- 第一个快照中不存在于第二个快照中的区域
- 第二个快照中不属于第一个快照的区域



### 解释 vmmap 的输出

输出列`vmmap`没有标题。相反，您可以按格式解释每列中的数据类型。表 1描述了这些列。



| 列数 | 例子                                                 | 描述                                                         |
| :--- | :--------------------------------------------------- | :----------------------------------------------------------- |
| 1    | `__TEXT`, `__LINKEDIT`, `MALLOC_USED`, `STACK`, 等等 | 记忆的目的。该列可以包含 Mach-O 段的名称或内存分配技术。     |
| 2    | `(DefaultMallocZone_0x5d2c0)`                        | 如果存在，则用于分配的区域。                                 |
| 3    | `4eee000`                                            | 该区域的虚拟内存地址。                                       |
| 4    | `[ 124K]`                                            | 该区域的大小，以千字节为单位                                 |
| 5    | `rw-/rwx`                                            | 该区域的读、写和执行权限。第一组标志指定该区域的当前保护。第二组值指定该区域的最大保护。如果条目包含破折号 ( `-`)，则该进程没有目标权限。 |
| 6    | `SM=PRV`                                             | 该区域的共享模式，`COW`（写入时复制）、`PRV`（私有）、`NUL`（空）、`ALI`（别名）或`SHM`（共享）。 |
| 7    | `...ts/MacOS/Clock`                                  | 标识映射到该虚拟内存区域的可执行文件的路径名末尾。如果该区域是堆栈或堆内存，则此列中不显示任何内容。 |

第 1 列标识内存的用途。段`__TEXT`包含只读代码和数据。段`__DATA`包含可读和可写的数据。对于分配的数据，此列显示内存是如何分配的，例如在堆栈上、使用`malloc`等等。对于从库加载的区域，最右列显示加载到内存中的库的名称。

虚拟内存区域的大小（第 4 列）表示为该区域保留的总大小。该数字可能不反映为该区域分配的实际内存页数。例如，调用`vm_allocate`保留一组内存页，但在实际访问这些页之前不会分配任何物理内存。类似地，内存映射文件可以保留一组页面，但系统不会加载页面，直到文件上发生读或写事件。

保护模式（第 5 列）描述了内存区域的访问限制。内存区域包含用于读取、写入和执行权限的单独标志。每个虚拟内存区域都有当前权限和最大权限。在 的输出中`vmmap`，首先显示当前权限，然后显示最大权限。因此，如果权限为“ `r--/rwx`”，则该页面当前是只读的，但允许读取、写入和执行访问作为其最大允许权限。通常，当前权限不允许写入区域。但是，这些权限在某些情况下可能会发生变化。例如，调试器可以请求对页面的写访问以设置断点。



**注意：** 代表 Mach-O 可执行文件一部分的页面通常不可写。第一页（`__PAGEZERO`，从地址 开始`0x00000000`）没有设置权限。这确保对`NULL`指针的任何引用都会立即导致错误。堆栈之前的页面也受到类似的保护，因此堆栈溢出会导致应用程序立即崩溃。



共享模式（`SM=`字段）告诉您页面是否在进程之间共享以及修改页面时会发生什么。私有页面 ( `PRV`) 仅对进程可见，并在使用时进行分配。私有页面也可以调出到磁盘。写时复制 ( `COW`) 页由多个进程共享（或由单个进程在多个位置共享）。当页面被修改时，写入进程会收到它自己的页面副本。空（`NUL`）共享意味着该页面并不真正存在于物理内存中。别名 ( `ALI`) 和共享 ( `SHM`) 内存在进程之间共享。

共享模式通常描述控制区域的通用模式。例如，当修改写时复制页面时，它们对应用程序变为私有。然而，包含这些私有页面的区域仍然是写时复制的，直到所有页面都变成私有的。一旦所有页面都是私有的，共享模式就会更改为私有。

输出中的一些行`vmmap`描述了子图。子映射是操作系统可以在多个进程之间重用的一组共享虚拟内存页面描述。`0x90000000`例如，和之间的内存`0xAFFFFFFF`是一个包含最常见动态库的子图。子映射通过仅表示一次虚拟内存区域来最大限度地减少操作系统的内存使用。子图可以由所有进程共享（机器范围），也可以是进程本地的（仅进程）。如果机器范围子映射的内容发生更改（例如，调试器使动态库的一部分内存可写，以便它可以插入调试陷阱），则子映射将变为本地子映射，并且内核会分配内存来存储额外的副本。
