### 问题：

耗时任务(这里指同步的任务) 如果在主线程，会导致卡顿等用户体验问题

### 处理场景1: 开辟子线程

开辟子线程处理耗时任务，回到主线程刷新UI

```objective-c
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    // 子线程耗时任务处理
    sleep(1.0);
    dispatch_async(dispatch_get_main_queue(), ^{
        // 主线程刷新UI
    });
});
```



### 处理场景2: RunLoopMode

假如需要显示图片等消耗CPU资源的操作，但是又需要在主线程处理。那么这个使用会导致滑动卡顿

解决方法是放入NSDefaultRunLoopMode  中处理

```objective-c
UIImageView *imageView = [UIImageView new];
[imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@"defaultimg"] afterDelay:0.1 inModes:@[NSDefaultRunLoopMode]];
```



### 处理场景3: 串行队列

当耗时任务涉及资源竞争时，为了保证资源读写的正确性，除了加锁，可以使用串行队列执行

```objective-c
__block int count = 3;
// 创建串行队列
dispatch_queue_t queue_sync = dispatch_queue_create("com.work.sync.queue", DISPATCH_QUEUE_SERIAL);
dispatch_async(queue_sync, ^{
    count --;
    NSLog(@"任务处理 count=%d ,线程：[%@] ",count, [NSThread currentThread]);
});
dispatch_async(queue_sync, ^{
    count --;
    NSLog(@"任务处理 count=%d ,线程：[%@] ",count, [NSThread currentThread]);
});
dispatch_async(queue_sync, ^{
    count --;
    NSLog(@"任务处理 count=%d ,线程：[%@] ",count, [NSThread currentThread]);
});
```

执行结果：

```scss
任务处理 count=2 ,线程：[<NSThread: 0x2814e75c0>{number = 6, name = (null)}] 
任务处理 count=1 ,线程：[<NSThread: 0x2814e75c0>{number = 6, name = (null)}] 
任务处理 count=0 ,线程：[<NSThread: 0x2814e75c0>{number = 6, name = (null)}] 
```

因为是串行队列任务，我们看到任务是依次执行的，这样效率会很低，所以下面介绍使用并行队列执行。



### 处理场景4: 并发队列

当耗时任务涉及资源竞争时，为了保证资源读写的正确性，除了串行队列，可以使用并发队列执行+栅栏函数处理。

注意这里是“并发队列” 而不是 “并行队列”， 

并发：

是拆分任务来回切换不同的任务执行，做到雨露均沾，本质上同一时间只能在执行某一个任务。

并行：

是指系统是多核的，任务在异步处理+多核情况下，同一时间可以做到真正的同时执行多个任务

```objective-c
// 并行队列
dispatch_queue_t queue_async = dispatch_queue_create("com.work.async.queue", DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue_async, ^{
    //读操作
    NSLog(@"读任务处理 count=%d ,线程：[%@] ",count, [NSThread currentThread]);
});

// 栅栏函数拦截异步任务，并进行写操作
dispatch_barrier_async(queue_async, ^{
    count --;
    NSLog(@"写任务处理 count=%d ,线程：[%@] ",count, [NSThread currentThread]);
});
dispatch_async(queue_async, ^{
    //读操作
    NSLog(@"读任务处理 count=%d ,线程：[%@] ",count, [NSThread currentThread]);
});
```



注意1：

栅栏函数dispatch_barrier_async不能使用在全局队列 global_queue中

注意2：

自定义队列设置了队列名称，在不同文件中投放到指定队列可以根据队列名称获取对应队列：

```objective-c
const char *
dispatch_queue_get_label(dispatch_queue_t _Nullable queue);
```

