### 1、实现：GCD+并发队列+任务组通知

简单依赖场景：任务1、2执行完成，最后执行3

```objective-c
dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_queue_create("com.work.async.queue", DISPATCH_QUEUE_CONCURRENT);
dispatch_group_async(group, queue, ^{
    sleep(1);
    NSLog(@"Work 1 [%@] ",[NSThread currentThread]);
});
dispatch_group_async(group, queue, ^{
    sleep(1);
    NSLog(@"Work 2 [%@] ",[NSThread currentThread]);
});
// 最后执行3
dispatch_group_notify(group, queue, ^{
    sleep(1);
    NSLog(@"Work 3 [%@] ",[NSThread currentThread]);
});
```



### 2、实现：栅栏函数+并发队列

```objective-c
dispatch_queue_t queue = dispatch_queue_create("barrier_test", DISPATCH_QUEUE_CONCURRENT);
        
dispatch_async(queue, ^{
    sleep(1);
    NSLog(@"Work 1 [%@] ",[NSThread currentThread]);
});

dispatch_async(queue, ^{
    sleep(1);
    NSLog(@"Work 2 [%@] ",[NSThread currentThread]);
});

dispatch_barrier_async(queue, ^{
    NSLog(@"Work barrier [%@] ",[NSThread currentThread]);
});

dispatch_async(queue, ^{
    sleep(1);
    NSLog(@"Work 3 [%@] ",[NSThread currentThread]);
});
```

执行

```scss
Work 2 [<NSThread: 0x283a640c0>{number = 5, name = (null)}]
Work 1 [<NSThread: 0x283a3bc40>{number = 3, name = (null)}]
Work barrier [<NSThread: 0x283a3bc40>{number = 3, name = (null)}]
Work 3 [<NSThread: 0x283a3bc40>{number = 3, name = (null)}]
```



### 3、实现：NSOperation+依赖

多个同步耗时任务，并且存在依赖关系的时候，可以使用 NSOperation

```objective-c
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
NSLog(@"Work begin [%@] ",[NSThread currentThread]);
NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
    // 任务代码
    sleep(1);
    NSLog(@"Work 1 [%@] ",[NSThread currentThread]);
}];

NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{
    sleep(1);
    NSLog(@"Work 2 [%@] ",[NSThread currentThread]);
}];

if (@available(iOS 13.0, *)) {
   [operation2 addDependency:operation1];
    // 不堵塞当前线程
    [queue addOperations:@[operation1, operation2] waitUntilFinished:NO];
    // 最后执行3
    [queue addBarrierBlock:^{
        NSLog(@"Work 3 [%@] ",[NSThread currentThread]);
    }];
} else {
    // 最后执行3
    NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"Work 3 [%@] ",[NSThread currentThread]);
    }];

    [operation2 addDependency:operation1];
    [operation3 addDependency:operation2];
    // 不堵塞当前线程
    [queue addOperations:@[operation1, operation2, operation3] waitUntilFinished:NO];
}

```

执行

```scss

Work begin [<_NSMainThread: 0x281560140>{number = 1, name = main}]
Work 1 [<NSThread: 0x281530080>{number = 4, name = (null)}]
Work 2 [<NSThread: 0x281506f00>{number = 7, name = (null)}]
Work 3 [<NSThread: 0x281506f00>{number = 7, name = (null)}]
```



1、waitUntilFinished:NO 表示不堵塞当前线程

2、NSBlockOperation 中任务会在子线程中执行

3、通过addDependency 可以控制任务执行顺序

4、信号量和GCD通知都不是默认支持复杂依赖关系的



### 4、实现：GCD+信号量（会堵塞当前线程，不推荐使用）

```objective-c
// 队列组
dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

// 创建信号量，并且设置值为2, 同时最多两个异步任务在执行
// semaphore > 0表示存在资源，可以执行， semaphore == 0，表示资源耗尽，需要等待其他线程释放资源
dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);

// 任务1
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 获取信号资源，同时 semaphore--
dispatch_group_async(group, queue, ^{

    NSLog(@"Work 1 [%@] ",[NSThread currentThread]);
    sleep(2);
    dispatch_semaphore_signal(semaphore); // 任务结束时，释放资源，semaphore++
});

// 任务2
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 获取信号资源，同时 semaphore--
dispatch_group_async(group, queue, ^{

    NSLog(@"Work 2 [%@] ",[NSThread currentThread]);
    sleep(1);
    dispatch_semaphore_signal(semaphore); // 任务结束时，释放资源，semaphore++
});

// 任务3

// 此时信号量 semaphore = 0，已经没有资源， 当前线程被阻塞。并等待信号量大于零
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
dispatch_group_async(group, queue, ^{

    NSLog(@"Work 3 [%@] ",[NSThread currentThread]);

    dispatch_semaphore_signal(semaphore); // 任务结束时，释放资源
});
```

执行

```scss
Work 1 [<NSThread: 0x28185e940>{number = 5, name = (null)}]
Work 2 [<NSThread: 0x281814e00>{number = 9, name = (null)}]
Work 3 [<NSThread: 0x281814e00>{number = 9, name = (null)}]
```









