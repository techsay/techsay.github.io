### 问题

通常存在一些业务场景，使用单例+block实现一些持续监听某些状态的能力，比如网络监听：

```objective-c
[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    // 更新业务逻辑
}];
```

显然这在单个文件中使用是可以的，但是一旦多处被使用，那么之前的文件中此代码将永远无法回调，显然是block被重置导致的。这样在不知不觉中，先前的业务逻辑就被影响了。



### 实现1: 

每次都新建一个对象，并创建了单独的block，不影响



### 实现2:

使用通知实现，这样只需要注册通知就可以了，单例只需要执行一次



### 实现3:

统一保存block，而不是直接修改set 方法

比如：

NSObject+BFNetReachable.h

```objective-c
#import <Foundation/Foundation.h>
#import <AFNetworking/AFNetworkReachabilityManager.h>

NS_ASSUME_NONNULL_BEGIN

typedef void(^didBFNetworkReachabilityStatusChangeBlock)(AFNetworkReachabilityStatus status);

@interface NSObject (BFNetReachable)

/// 添加网络监听（支持多个对象同时监听）
/// - Parameters:
///   - target: 监听对象
///   - block: 回调
- (void)netReachable_addMonitoringWithChangeBlock:(didBFNetworkReachabilityStatusChangeBlock)block;

@end

NS_ASSUME_NONNULL_END
```

NSObject+BFNetReachable.m

```objective-c

#import "NSObject+BFNetReachable.h"
#import <YYKit/YYKit.h>


@interface BFPrivateNetworkReachabilityManager : NSObject

@property (nonatomic, strong) NSMapTable *blockTable;
@property (nonatomic, strong) AFNetworkReachabilityManager *netManager;

@end

@implementation BFPrivateNetworkReachabilityManager

static BFPrivateNetworkReachabilityManager *_instance = nil;

+ (instancetype)shareInstance {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _instance = [[self alloc] init];
    });
    return _instance;
}


/// 添加网络监听
/// - Parameters:
///   - target: 监听对象
///   - block: 回调
- (void)addMonitoringWithTarget:(NSObject *)target statusChangeBlock:(didBFNetworkReachabilityStatusChangeBlock)block {
    @synchronized (self) {
        if (target && block) {
            [self.blockTable setObject:[block copy] forKey:target];
        } else {
            return;
        }
    }
    if (!_netManager) {
        @weakify(self)
        [self.netManager startMonitoring];
        [self.netManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
            @strongify(self)
            [self didReachabilityStatusChangedStatus:status];
        }];
    } else {
        !block ?: block(self.netManager.networkReachabilityStatus);
    }
}

- (void)didReachabilityStatusChangedStatus:(AFNetworkReachabilityStatus)status {
    NSEnumerator *enumerator = [self.blockTable keyEnumerator];
    id key;
    while ((key = [enumerator nextObject])) {
        didBFNetworkReachabilityStatusChangeBlock block = [self.blockTable objectForKey:key];
        !block ?: block(status);
    }
}

- (NSMapTable *)blockTable {
    if (!_blockTable) {
        _blockTable = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsWeakMemory valueOptions:NSPointerFunctionsStrongMemory capacity:1];
    }
    return _blockTable;
}

- (AFNetworkReachabilityManager *)netManager {
    if (!_netManager) {
        _netManager = [AFNetworkReachabilityManager manager];
    }
    return _netManager;
}

@end

@implementation NSObject (BFNetReachable)

/// 添加网络监听
/// - Parameters:
///   - target: 监听对象
///   - block: 回调
- (void)netReachable_addMonitoringWithChangeBlock:(didBFNetworkReachabilityStatusChangeBlock)block {
    [[BFPrivateNetworkReachabilityManager shareInstance] addMonitoringWithTarget:self statusChangeBlock:block];
}

@end

```

使用：

```objective-c
@weakify(self)
[self maasNetReachable_addMonitoringWithChangeBlock:^(AFNetworkReachabilityStatus status) {
    dispatch_async_on_main_queue(^{
        @strongify(self)
        if (status != AFNetworkReachabilityStatusNotReachable) {
            // 有网络
        }
    });
}];
```

