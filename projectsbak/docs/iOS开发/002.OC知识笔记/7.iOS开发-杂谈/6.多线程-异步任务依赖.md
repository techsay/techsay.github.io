### 说明

通常我们有自己的网络请求文件，比如如下简单的AF示例：

```objective-c
#pragma -mark 请求测试
- (void)testRequestWithUrl:(NSString *)url parameters:(NSDictionary *)parameters completed:(void(^)(NSObject * _Nullable responseObject, NSError * _Nullable error))completed {
    [[AFHTTPSessionManager manager] GET:url parameters:parameters headers:@{} progress:^(NSProgress * _Nonnull downloadProgress) {
        
    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        !completed ?: completed(responseObject, nil);
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        !completed ?: completed(nil, error);
    }];
}

```



通常情况下默认情况下 NSOperation 和 dispatch_group 和栅栏函数能够控制任务流程的原因是执行的是同步任务，然后投入到指定的队列中进行管理，假如现在要执行的是异步任务，然后投入到对应的队列中执行是无法获取正确结果的。因为这些函数不知道异步任务什么时候执行完成。

因此需要以下方式处理

### 1、实现：GCD+并发队列+任务组通知

dispatch_group_enter 和  dispatch_group_leave 要一一对应

```objective-c
dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_queue_create("com.work.async.queue", DISPATCH_QUEUE_CONCURRENT);

dispatch_group_enter(group);
dispatch_group_async(group, queue, ^{

    // 异步任务
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        sleep(1);
        NSLog(@"Work 1 [%@] ",[NSThread currentThread]);
        dispatch_group_leave(group);
    });

});


dispatch_group_enter(group);
dispatch_group_async(group, queue, ^{
    // 异步任务
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        sleep(1);
        NSLog(@"Work 2 [%@] ",[NSThread currentThread]);
        dispatch_group_leave(group);
    });

});

dispatch_group_notify(group, queue, ^{
    // 异步任务
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        sleep(1);
        NSLog(@"Work 3 [%@] ",[NSThread currentThread]);
    });
});
```

注意：可以方便实现多个异步函数任务结束时，最后执行其他任务的场景，其他较为复杂的依赖支持不是很好



### 2、实现：GCD+信号量（会堵塞当前线程）

```objective-c
// 队列组
dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

// 创建信号量，并且设置值为2, 同时最多两个异步任务在执行
// semaphore > 0表示存在资源，可以执行， semaphore == 0，表示资源耗尽，需要等待其他线程释放资源
dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);

// 任务1
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 获取信号资源，同时 semaphore--
dispatch_group_async(group, queue, ^{

    // 异步任务
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSLog(@"Work 1 [%@] ",[NSThread currentThread]);
        sleep(2);
        dispatch_semaphore_signal(semaphore); // 任务结束时，释放资源，semaphore++
    });

});

// 任务2
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 获取信号资源，同时 semaphore--
dispatch_group_async(group, queue, ^{
    // 异步任务
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSLog(@"Work 2 [%@] ",[NSThread currentThread]);
        sleep(1);
        dispatch_semaphore_signal(semaphore); // 任务结束时，释放资源，semaphore++
    });

});

// 任务3

// 此时信号量 semaphore = 0，已经没有资源， 当前线程被阻塞。并等待信号量大于零
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
dispatch_group_async(group, queue, ^{
    // 异步任务
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSLog(@"Work 3 [%@] ",[NSThread currentThread]);

        dispatch_semaphore_signal(semaphore); // 任务结束时，释放资源
    });

});
```

执行

```scss
Work 1 [<NSThread: 0x28185e940>{number = 5, name = (null)}]
Work 2 [<NSThread: 0x281814e00>{number = 9, name = (null)}]
Work 3 [<NSThread: 0x281814e00>{number = 9, name = (null)}]
```

注意：

1、会堵塞当前线程

2、信号量设置在某些场景容易导致崩溃，例如存在内存泄露的情况等等



### 3、实现：NSBlockOperation子类+依赖

通过NSBlockOperation子类自定义实现来弥补其不支持异步任务函数的状态监控缺陷，从而实现多异步函数之间的依赖

以下是重写NSBlockOperation start函数和相关 isFinished、isExecuting 等状态

（以下是实现思路）

------

**BFBlockOperation.h**

```objective-c

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

typedef void(^BFBlockOperationCompleted)(BOOL suc);
typedef void(^BFCreatOperationBlock)(BFBlockOperationCompleted complete);

@interface BFBlockOperation : NSBlockOperation

/// 使用系统方法创建时，异步任务使用此block返回执行完成的状态
@property(nonatomic, copy) BFBlockOperationCompleted completed;

/// 自定义创建方法,支持执行异步任务
+ (instancetype)asyncOperationWithBlock:(BFCreatOperationBlock)block;

@end

NS_ASSUME_NONNULL_END
```

**BFBlockOperation.m**

```objective-c

#import "BFBlockOperation.h"

typedef void(^BFBlockOperationCraeat)(void);

@interface BFBlockOperation ()

@property(nonatomic, assign) BOOL isFinished;
@property(nonatomic, assign) BOOL isExecuting;
@property(nonatomic, assign) BOOL isReady;
@property(nonatomic, copy) BFCreatOperationBlock opBlock;
@property(nonatomic, copy) BFBlockOperationCraeat creatBlock;

@end


@implementation BFBlockOperation

/// 自定义创建方法,支持执行异步任务
+ (instancetype)asyncOperationWithBlock:(BFCreatOperationBlock)block {
    BFBlockOperation *op = [[BFBlockOperation alloc] init];
    op.opBlock = block;
    [op willChangeValueForKey:@"isReady"];
    op.isReady = YES;
    [op didChangeValueForKey:@"isReady"];
    
    return op;
}

/// 重写系统创建方法,支持执行异步任务
+ (instancetype)blockOperationWithBlock:(void (^)(void))block {
    BFBlockOperation *op = [[BFBlockOperation alloc] init];
    op.creatBlock = block;
    [op willChangeValueForKey:@"isReady"];
    op.isReady = YES;
    [op didChangeValueForKey:@"isReady"];
    
    return op;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(checkStart) name:@"BFBlockOperation_FINISH_NOTIFICATION" object:nil];
    }
    return self;
}

- (BOOL)isAsynchronous {
    return YES;
}

- (void)start
{
    if (self.isExecuting) {
        return;
    }
    
    BOOL hasDepandens = NO;
    for (NSOperation *depenOP in self.dependencies) {
        if (!depenOP.isFinished) {
            hasDepandens = YES;
            break;
        }
    }
    if (hasDepandens) {
        NSLog(@"存在依赖，无法start");
        return;
    }
    
    [self willChangeValueForKey:@"isExecuting"];
    _isExecuting = YES;
    [self didChangeValueForKey:@"isExecuting"];
    if (self.creatBlock) {
        !self.creatBlock ?: self.creatBlock();
        __weak __typeof(self)weakSelf = self;
        self.completed = ^(BOOL suc) {
            __strong __typeof(weakSelf)strongSelf = weakSelf;
            [strongSelf checkStates];
        };
    } else if (self.opBlock) {
        BFBlockOperationCompleted completeBlock = ^(BOOL suc){
            if (self && self.isExecuting) {
                [self checkStates];
            }
        };
        !self.opBlock ?: self.opBlock(completeBlock);
    }
}

- (void)checkStart {
    if (!self || self.isFinished) {
        return;
    }
    [self start];
}

- (void)checkStates {
    [[NSOperationQueue mainQueue] addOperationWithBlock:^{
        [self finish];
        
        [[NSNotificationCenter defaultCenter] postNotificationName:@"BFBlockOperation_FINISH_NOTIFICATION" object:nil];
    }];
}


- (void)finish {
    [self willChangeValueForKey:@"isExecuting"];
    [self willChangeValueForKey:@"isFinished"];

    _isExecuting = NO;
    _isFinished = YES;

    [self didChangeValueForKey:@"isExecuting"];
    [self didChangeValueForKey:@"isFinished"];
}


@end

```



**使用子类来实现：**

```objective-c
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
queue.maxConcurrentOperationCount = 5; // 控制最大并发数

__block BFBlockOperation *operation = nil;
operation = [BFBlockOperation blockOperationWithBlock:^{
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        sleep(1.5);
        NSLog(@"Work 0 [%@] ",[NSThread currentThread]);
        !operation ?: operation.completed(YES); // block 内调用需要使用 __block 引用对象地址
    });
}];


BFBlockOperation *operation1 = [BFBlockOperation asyncOperationWithBlock:^(BFBlockOperationCompleted  _Nonnull complete) {
    // 任务代码
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        sleep(1.5);
        NSLog(@"Work 1 [%@] ",[NSThread currentThread]);
        !complete ?: complete(YES);
    });

}];

BFBlockOperation *operation2 = [BFBlockOperation asyncOperationWithBlock:^(BFBlockOperationCompleted  _Nonnull complete) {
    // 任务代码
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        sleep(1.0);
        NSLog(@"Work 2 [%@] ",[NSThread currentThread]);
        !complete ?: complete(YES);
    });

}];

BFBlockOperation *operation3 = [BFBlockOperation asyncOperationWithBlock:^(BFBlockOperationCompleted  _Nonnull complete) {
    // 任务代码
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        sleep(1.0);
        NSLog(@"Work 3 [%@] ",[NSThread currentThread]);
        !complete ?: complete(YES);
    });

}];

[operation1 addDependency:operation];
[operation1 addDependency:operation3];
[queue addOperations:@[operation, operation3,operation1, operation2] waitUntilFinished:NO]; // YES 的时候会堵塞当前线程，不要在主线程使用，除非任务在子线程中调用

```



优点：

1、支持多异步函数直接各种依赖关系

2、支持多异步函数的最大线程并发数

